#!/bin/env python
# -*- coding: utf-8 -*-
# copyright 2007-2011 Brecht Machiels
# copyright 2009-2010 Chris Roberts
# copyright 2009-2011 Scott McCreary
# copyright 2009 Alexander Deynichenko
# copyright 2009 HaikuBot (aka RISC)
# copyright 2010-2011 Jack Laxson (Jrabbit)
# copyright 2011 Ingo Weinhold
# copyright 2013 Oliver Tappe

info = {}
info['version'] = 'r' + '$Rev$'[6:-2]

# -- Modules ------------------------------------------------------------------

import hashlib
import locale
from optparse import OptionParser
import os
import re
import shutil
import string
from subprocess import check_call, PIPE, Popen, CalledProcessError
import sys
import tarfile
import time
import types
import urllib2
import zipfile

# -- HaikuPorts options -------------------------------------------------------

# location of haikuports.conf
haikuPortsConf = '/etc/haikuports.conf'

svnPath = 'http://ports.haiku-files.org/svn/haikuports/trunk'

# -----------------------------------------------------------------------------

# create new type 'StatusType' for identifying the port's status on a platform
#  the possible states are defined in the 'Config' class (reStatusType)
class status(str):
    pass

StatusType = status

# create new type 'PhaseType' for identifying a port phase
class phase(str):
    @staticmethod
    def getAllowedValues():
        return [ 'BUILD', 'TEST', 'INSTALL' ]

PhaseType = phase


# allowed types of the /etc/haikuports.conf values
confTypes = {}
confTypes['PACKAGES_PATH'] = types.StringType
confTypes['PATCH_OPTIONS'] = types.StringType
confTypes['PACKAGER'] = types.StringType

confDefaults = {}  # [required, default]
confDefaults['PACKAGES_PATH'] = [True, None]
confDefaults['PATCH_OPTIONS'] = [False, None]
confDefaults['PACKAGER'] = [True, None]

# allowed types of the recipe-file values
recipeTypes = {}
recipeTypes['BUILD_PACKAGE_ACTIVATION_PHASE'] = PhaseType
recipeTypes['BUILD_PREREQUIRES'] = types.ListType
recipeTypes['BUILD_REQUIRES'] = types.ListType
recipeTypes['CHECKSUM_MD5'] = types.StringType
recipeTypes['CONFLICTS'] = types.ListType
recipeTypes['COPYRIGHT'] = types.ListType
recipeTypes['DESCRIPTION'] = types.ListType
recipeTypes['FRESHENS'] = types.ListType
recipeTypes['HOMEPAGE'] = types.StringType
recipeTypes['LICENSE'] = types.ListType
recipeTypes['MESSAGE'] = types.StringType
recipeTypes['PROVIDES'] = types.ListType
recipeTypes['REPLACES'] = types.ListType
recipeTypes['REQUIRES'] = types.ListType
recipeTypes['REVISION'] = types.IntType
recipeTypes['SOURCE_DIR'] = types.StringType
recipeTypes['SRC_URI'] = types.ListType
recipeTypes['STATUS_HAIKU'] = StatusType
recipeTypes['SUMMARY'] = types.StringType
recipeTypes['SUPPLEMENTS'] = types.ListType

recipeDefaults = {}  # [required, default]
recipeDefaults['BUILD_PACKAGE_ACTIVATION_PHASE'] = [False, phase('BUILD')]
recipeDefaults['BUILD_PREREQUIRES'] = [False, []]
recipeDefaults['BUILD_REQUIRES'] = [False, []]
recipeDefaults['CHECKSUM_MD5'] = [False, None]
recipeDefaults['CONFLICTS'] = [False, []]
recipeDefaults['COPYRIGHT'] = [False, []]
recipeDefaults['DESCRIPTION'] = [True, None]
recipeDefaults['FRESHENS'] = [False, []]
recipeDefaults['HOMEPAGE'] = [True, None]
recipeDefaults['LICENSE'] = [False, []]
recipeDefaults['MESSAGE'] = [False, None]
recipeDefaults['PROVIDES'] = [True, None]
recipeDefaults['REPLACES'] = [False, []]
recipeDefaults['REQUIRES'] = [False, []]
recipeDefaults['REVISION'] = [True, 1]
recipeDefaults['SOURCE_DIR'] = [False, None]
recipeDefaults['SRC_URI'] = [True, []]
recipeDefaults['STATUS_HAIKU'] = [False, 'untested']
recipeDefaults['SUMMARY'] = [True, None]
recipeDefaults['SUPPLEMENTS'] = [False, []]
recipeDefaults['WORKING'] = [False, True]

# names of directories
paths = {}
paths['work'] = 'work'
paths['patches'] = 'patches'
paths['download'] = 'download'
paths['package'] = 'package'
paths['licenses'] = 'licenses'

# regex to split recipe filenames into port / version
regExp = {}
regExp['portname'] = '^(?P<name>[\w\-\+]+?)'
regExp['portversion'] = '(?P<version>[\w]*?[\d]+([\w\-\\.\+])*)'
regExp['portfullname'] = regExp['portname'] + '-' + regExp['portversion']
regExp['recipefilename'] = regExp['portfullname'] + '\.recipe$'


# Shell scriptlet that is used to execute a config file and output all the 
# configuration values (in the form of environment variables) which have been
# set explicitly in the configuration file. The first placeholder is substituted 
# with the configuration file, the second with a space separated list of 
# supported configuration keys.
# Note: this script requires bash, it won't work with any other shells
configFileEvaluatorScript = r'''# wrapper script for evaluating config/recipe
# stop on every error
set -e

# source the configuration file
. %s >/dev/null

# output all environment vars we are interested in and which have been set, 
# quoting any newlines in their values
NL=$'\n'
for key in %s 
do
    if [[ -n ${!key+dummy} ]]
    then
        value=${!key}
        echo "$key=${value//$NL/\\n}"
    fi
done
'''

# Shell scriptlet that is used to trigger one of the actions defined in a build
# recipe.The first placeholder is substituted with the configuration file, the 
# second one with the action to be invoked.
recipeActionScript = r'''# wrapper scriptlet for running an action
# stop on every error
set -e

# provide defaults for every action
BUILD()
{
    true
}

INSTALL()
{
    true
}

TEST()
{
    true
}

# source the configuration file
. %s >/dev/null

# invoke the requested action
echo $PWD
%s
'''


# -- capture output of shell command -----------------------------------------
def check_output(*popenargs, **kwargs):
    """local clone of subprocess.check_output() provided by python-2.7
       TODO: drop this once we have upgraded python to 2.7"""
    process = Popen(stdout=PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        raise CalledProcessError(retcode, cmd)
    return output


# -- Set up locale for thousands seperators ----------------------------------
def _ourLocaleconv(lc=locale.localeconv()):
    lc.update({'thousands_sep': ',', 'grouping': [3, 3, 0]})
    return lc


def findDirectory(aDir, subDirPath = None):
    result = check_output(['/bin/finddir', aDir]).rstrip()  # drop newline
    if subDirPath != None:
        result += '/' + subDirPath
    return result


locale.localeconv = _ourLocaleconv

# -- Main Program ------------------------------------------------------------
class HaikuPorter:
    def __init__(self, options, args):

        # read global settings
        mainConfig = Config(haikuPortsConf, confTypes)
        self.confKeys = mainConfig.getKeys()
        self.options = options

        # check whether all required fields are present
        for key in confDefaults:
            if key not in self.confKeys and confDefaults[key][0]:
                sys.exit("Error: Required field '" + key + "' not present in " 
                         + haikuPortsConf)

        self.packagesPath = self.confKeys['PACKAGES_PATH']
        if self.packagesPath[-1] == '/':
            # strip trailing '/'
            self.packagesPath = self.packagesPath[:-1]

        # if requested, list all ports in the HaikuPorts tree
        if options.list:
            self.searchPorts(None)
            sys.exit()

        # if requested, search for a port
        if options.search:
            if not args:
                sys.exit('You need to specify a search string.\n'
                         "Invoke '" + sys.argv[0] + " -h' for usage "
                         "information.")
            self.searchPorts(args[0])
            sys.exit()
        
        if options.location:
            if not args:
                sys.exit('You need to specify a search string.\n'
                         "Invoke '" + sys.argv[0] + " -h' for usage "
                         "information.")
            # Provide the installed location of a recipe (for quick editing)
            print os.path.join(self.packagesPath, self.searchPorts(args[0]))
            sys.exit()

        # if requested, checkout or update ports tree
        if options.get:
            self.updatePortsTree()
            sys.exit()

        # if requested, print the location of the haikuports source tree
        if options.tree:
            print self.packagesPath
            sys.exit()

        # if requested, scan the ports tree for problems
        if options.lint:
            self.checkSourceTree()
            sys.exit()

        # if there is no argument given, exit
        if not args:
            sys.exit('You need to specify a search string.\n'
                     "Invoke '" + sys.argv[0] + " -h' for usage information.")
        else:
            port = args[0]

        # split the argument into a port name and a version
        reWithVersion = re.compile(regExp['portfullname'])
        reWithoutVersion = re.compile(regExp['portname'] + '$')
        if reWithVersion.match(port):  # with version
            m = reWithVersion.match(port)
            self.portName = m.group('name')
            self.portVersion = m.group('version')
        elif reWithoutVersion.match(port):
            m = reWithoutVersion.match(port)
            self.portName = m.group('name')
            self.portVersion = None
        else:
            # invalid argument
            sys.exit('Error: Invalid port name ' + port)
            
        # find the port in the HaikuPorts tree
        self.portCategory = self.getCategory(self.portName)
        if self.portCategory == None:
            sys.exit('Error: Port ' + self.portName + ' not found.')

        # create full paths for the directories
        self.portDir = (self.packagesPath + '/' + self.portCategory + '/' +
                        self.portName)
        self.downloadDir = self.portDir + '/' + paths['download']
        self.workDir = self.portDir + '/' + paths['work']
        self.sourceDir = self.workDir
        self.patchesDir = self.portDir + '/' + paths['patches']
        self.packageDir = self.portDir + '/' + paths['package']

        # if the port version was not specified, list available versions
        if self.portVersion == None:
            versions = []
            reRecipeFile = re.compile(regExp['recipefilename'])
            dirList = os.listdir(self.portDir)
            for item in dirList:
                m = reRecipeFile.match(item)
                if m:
                    versions.append([m.group('version'), item])
            if len(versions) > 1:
                print 'Following versions of %s are available:' % self.portName
                for version in versions:
                    print '  ' + version[0]
                sys.exit('Run haikuporter again, specifying a port version')
            elif len(versions) == 1:
                self.portVersion = versions[0][0]
            else:
                sys.exit('Error: .recipe files for %s not found.' % self.portName)

        # show port description, if requested
        if options.about:
            self.printDescription()
            sys.exit()

        # set up the variables we'll inherit to the shell
        self.portVersionedName = self.portName + '-' + self.portVersion
        self.initGlobalShellVariables()

        # read data from the recipe file
        self.parseRecipeFile()

        # If a SOURCE_DIR was specified, make it absolute.
        if self.recipeKeys['SOURCE_DIR']:
            self.sourceDir = self.workDir + '/' + self.recipeKeys['SOURCE_DIR']

        # set up the variables we'll inherit to the shell
        self.initShellVariablesFromRecipe()

        # warn when the port is not stable on this platform
        self.platform = self.detectOS()
        if self.platform == None:
            sys.exit('Error: Unknown OS platform!')
        elif self.recipeKeys['STATUS_' + self.platform] != 'stable':
            print ('Warning: This port is %s on this platform.' %
                   self.recipeKeys['STATUS_' + self.platform])
            if not self.options.yes:
                answer = raw_input('Continue (y/n + enter)? ')
                if answer == '':
                    sys.exit(1)
                if answer[0].lower() == 'y':
                    print ' ok'
                else:
                    sys.exit(1)

        if self.recipeKeys['MESSAGE']:
            print self.recipeKeys['MESSAGE']
            if not self.options.yes:
                answer = raw_input('Continue (y/n + enter)? ')
                if answer == '':
                    sys.exit(1)
                if answer[0].lower() == 'y':
                    print ' ok'
                else:
                    sys.exit(1)

        # clean the work dir and don't build when making a source archive
        if options.archive:
            options.build = False
            options.clean = True
            options.patch = True

        # clean the work directory, if requested
        if options.clean:
            self.cleanWorkDirectory()

        # don't build when not patching
        if not options.patch:
            options.build = False

        try:
            self.activeBuildPackage = None
            self.checkDependencies()
            self.downloadSource()
            self.checksumSource()
            self.unpackSource()
            if options.patch:
                self.patchSource()
            if options.build:
                self.buildPort()
            if options.package:
                self.makePackage()
            if options.archive:
                self.makePatchedArchive()
            if options.test:
                self.testPort()
        finally:
            self.deactivateBuildPackage()

    def initGlobalShellVariables(self):
        # extract the package info from the system package
        output = check_output('package list /system/packages/haiku.hpkg'
            + ' | grep -E "^[[:space:]]*[[:alpha:]]+:[[:space:]]+"', shell=True)

        # get the haiku version
        match = re.search(r"provides:\s*haiku\s+=\s*(\S+)", output);
        if not match:
            sys.exit('Failed to get Haiku version!')
        self.haikuVersion = match.group(1)

        # get the architecture
        match = re.search(r"architecture:\s*(\S+)", output);
        if not match:
            sys.exit('Failed to get Haiku architecture!')
        self.architecture = match.group(1)

        self.shellVariables = {
            'haikuVersion': self.haikuVersion,
            'architecture': self.architecture,
            'portVersion': self.portVersion,
            'portVersionedName': self.portVersionedName,
        }

    def initShellVariablesFromRecipe(self):
        self.portRevision = str(self.recipeKeys['REVISION'])
        self.portFullVersion = self.portVersion + '-' + self.portRevision
        self.portRevisionedName = self.portName + '-' + self.portFullVersion
        prefix = findDirectory('B_PACKAGE_LINKS_DIRECTORY',
            self.portRevisionedName + '/.self')

        self.shellVariables.update({
            'portRevision': self.portRevision,
            'portFullVersion': self.portFullVersion,
            'portRevisionedName': self.portRevisionedName,
            'prefix': prefix,
            'dataRootDir': prefix + '/data',
            'binDir': prefix + '/bin',
            'sbinDir': prefix + '/bin',
            'libDir': prefix + '/lib',
            'includeDir': prefix + '/develop/headers',
            'sysconfDir': prefix + '/settings',
            'docDir': prefix + '/documentation/packages/' + self.portName,
            'infoDir': prefix + '/documentation/info',
            'manDir': prefix + '/documentation/man',
            'sourceDir': self.sourceDir,
            'jobs': str(self.options.jobs),
        })
        self.shellVariables['configureDirArgs'] = \
            '--prefix=$prefix '                   \
            '--datarootdir=$dataRootDir '         \
            '--sbindir=$sbinDir '                 \
            '--includedir=$includeDir '           \
            '--sysconfdir=$sysconfDir '           \
            '--docdir=$docDir '                   \
            '--infodir=$infoDir '                 \
            '--mandir=$manDir'

    def printDescription(self):
        """Show port description"""
        recipeFilePath = (self.portDir + '/' + self.portName + '-' +
                          self.portVersion + '.recipe')
        recipeConfig = Config(recipeFilePath, recipeTypes, self.shellVariables)
        self.recipeKeys = recipeConfig.getKeys()

        print '*' * 80
        if 'SUMMARY' in self.recipeKeys:
            print 'DESCRIPTION: %s' % self.recipeKeys['SUMMARY']
        if 'HOMEPAGE' in self.recipeKeys:
            print 'HOMEPAGE: %s' % self.recipeKeys['HOMEPAGE']
        print '*' * 80

    def setFlag(self, name):
        open('%s/%s-%s.%s' % (self.workDir, self.portName,
             self.portVersion, name), 'w').close()

    def checkFlag(self, name):
        if os.path.exists('%s/%s-%s.%s' % (self.workDir, self.portName,
                                           self.portVersion, name)):
            return True
        else:
            return False

    def updatePortsTree(self):
        """Get/Update the port tree via svn"""
        print 'Refreshing the port tree: %s' % self.packagesPath
        if os.path.exists(self.packagesPath + '/.svn'):
            check_call(['svn', 'update', self.packagesPath])
        else:
            check_call(['svn', 'checkout', svnPath, self.packagesPath])

    def validateRecipeFile(self, recipeFilePath):
        """Validate the keys/values in a recipe file"""
        recipeConfig = Config(recipeFilePath, recipeTypes, self.shellVariables)
        self.recipeFilePath = recipeFilePath
        self.recipeKeys = recipeConfig.getKeys()

        # check whether all required fields are present
        for key in recipeDefaults:
            if key not in self.recipeKeys and recipeDefaults[key][0]:
                sys.exit("Error: Required field '" + key\
                         + "' not present in " + recipeFilePath)

        # Check for a valid license file
        if 'LICENSE' in self.recipeKeys:
            fileList = []
            recipeLicense = self.recipeKeys['LICENSE']
            for item in recipeLicense:
                dirname = findDirectory('B_SYSTEM_DIRECTORY', 'data/licenses')
                haikuLicenseList = fileList = os.listdir(dirname)
                if item not in fileList:
                    fileList = []
                    dirname = os.path.dirname(recipeFilePath) + '/licenses'
                    print 'Try looking in ' + dirname
                    if os.path.exists(dirname):
                        for filename in os.listdir(dirname):
                            fileList.append(filename)
                if item not in fileList:
                    haikuLicenseList.sort()
                    sys.exit(('\n######## Error: No match found for License %s '
                              '########\n' % item) + '\n'
                              + 'Valid license filenames included with Haiku '
                              + 'are:\n\n' + '\n'.join(haikuLicenseList) + '\n')
                else:
                    print 'Matching License (%s) found in %s' % (item, dirname)

        if 'LICENSE' not in self.recipeKeys or not self.recipeKeys['LICENSE']:
            print 'Warning: No LICENSE found in recipe file'

        if 'COPYRIGHT' not in self.recipeKeys or not self.recipeKeys['COPYRIGHT']:
            print 'Warning: No COPYRIGHT found in recipe file'

    def parseRecipeFile(self):
        """Parse the recipe-file of the specified port"""
        recipeFilename = (self.portDir + '/' + self.portName + '-' +
                          self.portVersion + '.recipe')
        if not os.path.exists(recipeFilename):
            sys.exit('Error: ' + self.portName + ' version '
                      + self.portVersion + ' not found.')

        self.validateRecipeFile(recipeFilename)

        # set default values when not provided
        for key in recipeDefaults:
            if key not in self.recipeKeys:
                self.recipeKeys[key] = recipeDefaults[key][1]

        # for key in self.recipeKeys:
        #     print key + " = " + str(self.recipeKeys[key])

    def detectOS(self):
        """Detect the platform we're running on"""
        return 'HAIKU'

    def searchPorts(self, regExp):
        """Search for a port in the HaikuPorts tree"""
        if regExp:
            reSearch = re.compile(regExp)
        hierarchy = []
        os.chdir(self.packagesPath)
        dirList = os.listdir(self.packagesPath)
        for category in dirList:
            if os.path.isdir(category) and category[0] != '.':
                subdirList = os.listdir(category)
                # remove items starting with '.'
                subdirList.sort()
                for portName in subdirList:
                    if (portName[0][0] != '.' and (not regExp or
                                                   reSearch.search(portName))):
                        print category + '/' + portName

    def getCategory(self, portName):
        """Find location of the specified port in the HaikuPorts tree"""
        hierarchy = []
        os.chdir(self.packagesPath)
        dirList = os.listdir(self.packagesPath)
        for item in dirList:
            if os.path.isdir(item) and item[0] != '.':
                subdirList = os.listdir(item)
                # remove items starting with '.'
                subdirList.sort()
                while subdirList[0][0] == '.':
                    del subdirList[0]

                # locate port
                try:
                    if subdirList.index(portName) >= 0:
                        # port was found in the category specified by 'item'
                        return item
                except ValueError:
                    pass
                hierarchy.append([item, subdirList])
        return None

    def cleanWorkDirectory(self):
        """Clean the working directory"""
        if os.path.exists(self.workDir):
            print 'Cleaning work directory...'
            shutil.rmtree(self.workDir)
                

    def checkDependencies(self):
        """Print the list of ports this one depends on"""
        if self.recipeKeys['REQUIRES'] == []:
            print 'No dependencies'
            return
        print 'This port depends on the following ports:'
        for item in self.recipeKeys['REQUIRES']:
            print '  ' + item
        print 'Please verify that you have these installed.',
        if not self.options.yes:
            answer = raw_input('Continue (y/n + enter)? ')
            if answer == '':
                sys.exit(1)
            if answer[0].lower() == 'y':
                print ' ok'
            else:
                sys.exit(1)

    def downloadSource(self):
        """Fetch the source archive"""
        for src_uri in self.recipeKeys['SRC_URI']:
            # Examine the URI to determine if we need to perform a checkout
            # instead of download
            if re.match('^cvs.*$|^svn.*$|^hg.*$|^git.*$|^bzr.*$',
                        src_uri):
                self.checkoutSource(src_uri)
                return

            try:
                # Need to make a request to get the actual uri in case it is an
                # http redirect
                uri_request = urllib2.urlopen(src_uri)
                src_uri = uri_request.geturl()

                self.src_local = src_uri[src_uri.rindex('/') + 1:]
                fp = self.downloadDir + '/' + self.src_local
                if os.path.isfile(fp):
                    print 'File already exists: ' + fp\
                         + '\nSkipping download ...'
                    return
                else:
                    # create download dir and cd into it
                    if not os.path.exists(self.downloadDir):
                        os.mkdir(self.downloadDir)

                    os.chdir(self.downloadDir)

                    print '\nDownloading: ' + src_uri
                    check_call(['wget', '-c', '--tries=3', src_uri])

                    # succesfully downloaded source archive
                    return
            except:
                print 'Warning: download error, trying next location.'

        # failed to fetch source
        sys.exit('Error: Failed to download source package from all locations.')

    def checkoutSource(self, uri):
        """Parse the URI and execute the appropriate command to check out the
         source.
                 
        """
        if self.checkFlag('checkout') and not self.options.force:
            print 'Source already checked out. Skipping ...'
            return

        # If the work dir exists we need to clean it out
        if os.path.exists(self.workDir):
            shutil.rmtree(self.workDir)

        print 'Source checkout: ' + uri

        # Attempt to parse a URI with a + in it. ex: hg+http://blah
        # If it doesn't find the 'type' it should extract 'real_uri' and 'rev'
        m = re.match('^((?P<type>\w*)\+)?(?P<real_uri>.+?)(#(?P<rev>.+))?$',
                     uri)
        if not m or not m.group('real_uri'):
            sys.exit("Error: Couldn't parse repository URI")

        type = m.group('type')
        real_uri = m.group('real_uri')
        rev = m.group('rev')

        # Attempt to parse a URI without a + in it. ex: svn://blah
        # TODO improve the regex above to fallback to this pattern
        if not type:
            m = re.match("^(\w*).*$", real_uri)
            if m:
                type = m.group(1)

        if not type:
            sys.exit("Error: Couldn't determine repository type")

        # Set the name of the directory to check out sources into
        checkoutDir = self.portName + '-' + self.portVersion

        # Start building the command to perform the checkout
        if type == 'cvs':
            # Chop off the leading cvs:// part of the uri
            real_uri = real_uri[real_uri.index('cvs://') + 6:]

            # Extract the cvs module from the uri and remove it from real_uri
            module = real_uri[real_uri.rfind('/') + 1:]
            real_uri = real_uri[:real_uri.rfind('/')]
            checkoutCommand = 'cvs -d' + real_uri + ' co -P'
            if rev:
                # For CVS 'rev' specifies a date
                checkoutCommand += ' -D' + rev
            checkoutCommand += ' -d ' + checkoutDir + ' ' + module
        elif type == 'svn':
            checkoutCommand = \
                'svn co --non-interactive --trust-server-cert'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'hg':
            checkoutCommand = 'hg clone'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'bzr':
            # http://doc.bazaar.canonical.com/bzr-0.10/bzr_man.htm#bzr-branch-from-location-to-location
            checkoutCommand = 'bzr checkout --lightweight'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        else:
            # TODO Skip the initial checkout if a rev is specified?
            checkoutCommand = 'git clone %s %s' % (real_uri, checkoutDir)
            if rev:
                checkoutCommand += (' && cd %s'
                                    ' && git checkout %s' % (checkoutDir, rev))

        # create the work dir
        if not os.path.exists(self.workDir):
            os.mkdir(self.workDir)

        try:
            check_call(checkoutCommand, shell=True, cwd=self.workDir)
        except (OSError, CalledProcessError) as e:
            if self.prompt_installer(checkoutCommand.split()[0]):
                check_call(checkoutCommand, shell=True,
                           cwd=self.workDir)
            else:
                sys.exit(e)

        # Set the 'checkout' flag to signal that the checkout is complete
        # This also tells haikuporter not to attempt an unpack step
        self.setFlag('checkout')

    def checksumSource(self):
        if self.recipeKeys['CHECKSUM_MD5']:
            sys.stdout.write('Calculating checksum -')
            sys.stdout.flush()
            h = hashlib.md5()
            f = open(self.downloadDir + '/' + self.src_local, 'rb')
            while True:
                d = f.read(16384)
                if not d:
                    break
                h.update(d)
            f.close()
            if h.hexdigest() == self.recipeKeys['CHECKSUM_MD5']:
                sys.stdout.write(' OK\n')
            else:
                sys.exit(' FAILED\nExpected: ' + self.recipeKeys['CHECKSUM_MD5'] 
                         +  '\nFound: ' + h.hexdigest() + '\n')
            sys.stdout.flush()
        else:
            # The checkout flag only gets set when a source checkout is performed
            # If it exists we don't need to warn about the missing recipe field
            if not self.checkFlag('checkout'):
                print 'Warning: CHECKSUM_MD5 key not found in recipe file.'

    def unpackSource(self):
        """Unpack the source archive (into the work directory)"""

        # If the source came from a vcs there is no unpack step
        if self.checkFlag('checkout'):
            return

        # create work dir
        if not os.path.exists(self.workDir):
            os.mkdir(self.workDir)

        # Check to see if the source archive was already unpacked.
        if self.checkFlag('unpack') and not self.options.force:
            return

        # unpack source archive
        print 'Unpacking ' + self.src_local
        archiveFullPath = self.downloadDir + '/' + self.src_local
        if tarfile.is_tarfile(archiveFullPath):
            tf = tarfile.open(self.downloadDir + '/' + self.src_local,
                              'r')
            tf.extractall(self.workDir)
            tf.close()
        elif zipfile.is_zipfile(archiveFullPath):
            zf = zipfile.ZipFile(self.downloadDir + '/'
                                  + self.src_local, 'r')
            zf.extractall(self.workDir)
            zf.close()
        elif archiveFullPath.split('/')[-1].split('.')[-1] == 'xz':
            try:
                Popen(['xz', '-d', '-k', archiveFullPath])
            except (OSError, CalledProcessError) as e:
                # run the installoptionalsoftware prompt
                if self.prompt_installer('xz'):
                    Popen(['xz', '-d', '-k', archiveFullPath])
                else:
                    sys.exit(e)
            tar = archiveFullPath[:-3]
            if tarfile.is_tarfile(tar):
                tf = tarfile.open(tar, 'r')
                tf.extractall(self.workDir)
                tf.close()
        else:
            sys.exit('Error: Unrecognized archive type.')

        self.setFlag('unpack')

    def patchSource(self):
        """Apply the Haiku patches to the source directory"""
        # Check to see if the patch was already applied to the source.
        if self.checkFlag('patch') and not self.options.force:
            return

        patchFilePath = self.patchesDir + '/' + self.portName + '-'\
             + self.portVersion + '.patch'
        if os.path.exists(patchFilePath):
            patchOptions = ''
            if 'PATCH_OPTIONS' in self.confKeys:
                patchOptions += self.confKeys['PATCH_OPTIONS']
            check_call('patch -p0 ' + patchOptions + ' -i '
                        + patchFilePath, shell=True, cwd=self.workDir)
        else:
            print 'No patching required'
        self.setFlag('patch')

    def activateBuildPackage(self):
        """Create and activate the build package"""
        # create a package info for a build package
        buildPackageInfo = self.workDir + '/' + self.portRevisionedName +\
            '-build-package-info'
        self.generatePackageInfo(buildPackageInfo, True)

        # create the build package
        buildPackage = self.workDir + '/' + self.portRevisionedName +\
            '-build.hpkg'
        check_call(['package', 'create', '-bi', buildPackageInfo, '-I',
            self.packageDir, buildPackage])

        # activate the build package
        packagesDir = findDirectory('B_COMMON_PACKAGES_DIRECTORY')
        activeBuildPackage \
            = packagesDir + '/' + os.path.basename(buildPackage)
        try:
            os.remove(activeBuildPackage)
        except OSError:
            pass
        os.symlink(buildPackage, activeBuildPackage)
        self.activeBuildPackage = activeBuildPackage

    def deactivateBuildPackage(self):
        """Deactivate the build package, if it has been activated"""
        if self.activeBuildPackage:
            try:
	            os.remove(self.activeBuildPackage)
            except OSError:
                pass
	        self.activeBuildPackage = None

    def buildPort(self):
        """Build the sources"""
        # Check to see if a previous build was already done.
        if self.checkFlag('build') and not self.options.force:
            return

        # activate build package if required at this stage
        if self.recipeKeys['BUILD_PACKAGE_ACTIVATION_PHASE'] == 'BUILD':
            self.activateBuildPackage()
            
        # Delete and re-create the package dir -- the port's build may need to
        # use it.
        shutil.rmtree(self.packageDir, True)
        if not os.path.exists(self.packageDir):
            os.mkdir(self.packageDir)

        self.doRecipeAction('BUILD', self.sourceDir)
        self.setFlag('build')

    def installPort(self):
        """Install the binaries onto the system"""
        # activate build package if required at this stage
        if self.recipeKeys['BUILD_PACKAGE_ACTIVATION_PHASE'] == 'INSTALL':
            self.activateBuildPackage()
            
        print 'Installing ...'
        self.doRecipeAction('INSTALL', self.sourceDir)

    def testPort(self):
        """Test the resulting binaries"""
        # activate build package if required at this stage
        if self.recipeKeys['BUILD_PACKAGE_ACTIVATION_PHASE'] == 'TEST':
            self.activateBuildPackage()
            
        print 'Testing ...'
        self.doRecipeAction('TEST', self.sourceDir)

    def generatePackageInfo(self, packageInfoPath, isBuildPackage):
        """Create an .PackageInfo file for inclusion in a package"""
        print 'Generating .PackageInfo file ...'

        infoFile = open(packageInfoPath, 'w')
        infoFile.write('name\t\t\t' + self.portName + '\n')
        infoFile.write('version\t\t\t' + self.portFullVersion + '\n')
        infoFile.write('architecture\t\t' + self.architecture + '\n')
        infoFile.write('summary\t\t\t"' + self.recipeKeys['SUMMARY'] + '"\n')

        infoFile.write('description\t\t"')
        lineNumber = 0
        for line in self.recipeKeys['DESCRIPTION']:
            if lineNumber > 0:
                infoFile.write('\n')
            infoFile.write(line)
            lineNumber += 1
        infoFile.write('"\n')

        infoFile.write('packager\t\t"' + self.confKeys['PACKAGER'] + '"\n')
        infoFile.write('vendor\t\t\t"Haiku Project"\n')

        # These keys aren't mandatory so we need to check if they exist
        if self.recipeKeys['LICENSE']:
            infoFile.write('licenses {\n')
            for license in self.recipeKeys['LICENSE']:
                infoFile.write('\t"' + license + '"\n')
            infoFile.write('}\n')

        if self.recipeKeys['COPYRIGHT']:
            infoFile.write('copyrights {\n')
            for copyright in self.recipeKeys['COPYRIGHT']:
                infoFile.write('\t"' + copyright + '"\n')
            infoFile.write('}\n')

        if isBuildPackage:
            dependencies = self.recipeKeys['REQUIRES'] \
            	+ self.recipeKeys['BUILD_REQUIRES'] \
            	+ self.recipeKeys['BUILD_PREREQUIRES']
        else:
            dependencies = self.recipeKeys['REQUIRES']

        self.writePackageInfoListByKey(infoFile, 'PROVIDES', 'provides')
        self.writePackageInfoList(infoFile, dependencies, 'requires')
        self.writePackageInfoListByKey(infoFile, 'SUPPLEMENTS', 'supplements')
        self.writePackageInfoListByKey(infoFile, 'CONFLICTS', 'conflicts')
        self.writePackageInfoListByKey(infoFile, 'FRESHENS', 'freshens')
        self.writePackageInfoListByKey(infoFile, 'REPLACES', 'replaces')

        infoFile.write('urls\t\t\t"' + self.recipeKeys['HOMEPAGE'] + '"\n')

        # Generate SourceURL lines for all ports, regardless of license.
        # Re-use the download URLs, as specified in the recipe.
        infoFile.write('source-urls {\n')
        uricount = 1
        for src_uri in self.recipeKeys['SRC_URI']:
            if uricount < 2:
                infoFile.write('\t"Download <' + src_uri + '>"\n')
            else:
                infoFile.write('\t"Location ' + str(uricount) + ' <' + src_uri
                    + '>"\n')
            uricount += 1

        # Point directly to the file in subversion.
        recipeurl_base = 'http://ports.haiku-files.org/' + \
            'svn/haikuports/trunk/' + self.portCategory + '/' + self.portName

        recipeurl = recipeurl_base + '/' + self.portName+ '-'\
            + self.portVersion + '.recipe'

        infoFile.write('\t"Recipe-file <' + recipeurl + '>"\n')
        patchFilePath = self.patchesDir + '/' + self.portName + '-'\
            + self.portVersion + '.patch'
        if os.path.exists(patchFilePath):
            patchurl = recipeurl_base + '/patches/' + self.portName + '-' + self.portVersion + '.patch'
            infoFile.write('\t"Patches <' + patchurl + '>"\n')

        infoFile.write('}\n')

        infoFile.close()
        infoFile = open(packageInfoPath, 'r')
        infoFileDisplay = infoFile.read()
        print infoFileDisplay
        infoFile.close()

    def writePackageInfoListByKey(self, infoFile, key, keyword):
        self.writePackageInfoList(infoFile, self.recipeKeys[key], keyword)

    def writePackageInfoList(self, infoFile, list, keyword):
        if list:
            infoFile.write(keyword + ' {\n')
            for item in list:
                infoFile.write('\t' + item + '\n')
            infoFile.write('}\n')

    def makePackage(self):
        """Create a package suitable for distribution"""
        print 'Creating distribution package ...'

        # if the package dir still exists from a previous run then remove it
        shutil.rmtree(self.packageDir, True)

        # create package dir
        if not os.path.exists(self.packageDir):
            os.mkdir(self.packageDir)

        for f in os.listdir(self.portDir):
            if f == 'licenses':
                shutil.copytree(self.portDir + '/' + f,
                    self.packageDir + '/data/licenses')

        self.installPort()

        self.generatePackageInfo(self.packageDir + '/.PackageInfo', False)

        # go to package dir for making the package
        os.chdir(self.packageDir)

        package = self.portName + '-' + self.portVersion

        # set haikuversion to HAIKUVERSION, if it is empty then don't add a
        # dash.
        haikuversion = ''
        if 'HAIKUVERSION' in os.environ:
            haikuversion = '-' + os.environ['HAIKUVERSION']

        date = time.strftime('-%Y-%m-%d', time.localtime())

        packageFile = self.portDir + '/' + self.portRevisionedName + '-'\
             + self.architecture + '.hpkg'

        packageFiles = ''

        # # If -c, wipeout old zips
        # if self.options.clean:
        #     for item in os.listdir(self.portDir):
        #         if item[-4:] == '.zip':
        #             os.remove(os.path.join(self.portDir, item))
        
        # Test if package already exists, and if so delete so that it will be
        # the newest.
        if os.path.exists(packageFile):
            os.remove(packageFile)
        
        # Create the package and save it in the root of the port dir
        check_call(['package', 'create', packageFile])

        # Clean up after ourselves
        shutil.rmtree(self.packageDir)

        print 'Package saved to: ' + packageFile
        if self.recipeKeys['LICENSE']:
            if ' '.join(self.recipeKeys['LICENSE'][0].split()[:2]) in ['GNU GPL', 'GNU LGPL']:
                print ('To generate the matching source package, run: '
                       'haikuporter -z ' + package)

    def makePatchedArchive(self):
        """Create a patched source archive"""
        print 'Creating patched source archive ...'

        # Set the path and filename for the archive.
        date = time.strftime('-%Y-%m-%d', time.localtime())
        archiveFile = self.portDir + '/' + self.portName + '-'\
             + self.portVersion + '_haiku' + date + '.tar.xz'

        sourceFiles = ''

        # Build the list of dirs to archive.
        # Since we don't know the name we have to iterate over the dir.
        for f in os.listdir(self.workDir):
            if os.path.isdir(self.workDir + '/' + f):
                sourceFiles += ' ' + f

        # Make sure we found something to archive
        if not sourceFiles:
            sys.exit('Error: No source directories found in work dir.')

        # Archive the package and save it in the root of the port dir.
        check_call('tar cJvf ' + archiveFile + ' ' + sourceFiles,
                   shell=True, cwd=self.workDir)

        # Clean up after ourselves
        shutil.rmtree(self.workDir)

        print 'Archive saved to: ' + archiveFile

    def prompt_installer(self, name):
        apps = {  # map command to package
            'xz': 'XZ-Utils',
            'git': 'Git',
            'hg': 'mercurial',
            'cvs': 'cvs',
            'bzr': 'bazaar',
            }
        if self.options.yes:
            check_call('installoptionalpackage' + ' '
                        + str(apps[name]), shell=True)
            return True
        response = raw_input('Do you want to install %s? [Y/n]' % name)
        if response in ['y', 'Y', '\n', 'yes', '']:
            check_call('installoptionalpackage' + ' '
                        + str(apps[name]), shell=True)
            return True
        else:
            print ('In order to install this package you need to run '
                   'installoptionalpackage %s later or let Haikuporter install '
                   'it for you.' % apps[name])
            return False

    def doRecipeAction(self, action, dir):
        """Run the specified action, as defined in the recipe file"""

        # set up the shell environment -- we want it to inherit some of our
        # variables
        shellEnv = os.environ
        shellEnv.update(self.shellVariables)

        # execute the requested action via a shell ....
        wrapperScript = recipeActionScript % (self.recipeFilePath, action)
        check_call(['/bin/bash', '-c', wrapperScript], cwd=dir, env=shellEnv)

    def checkSourceTree(self):
        print 'Checking HaikuPorts tree at: ' + self.packagesPath

        for category in os.listdir(self.packagesPath):
            categoryFullPath = self.packagesPath + '/' + category
            if os.path.isdir(categoryFullPath) and category[0] != '.':
                print 'Category: ' + category
                for port in os.listdir(categoryFullPath):
                    portFullPath = categoryFullPath + '/' + port
                    if os.path.isdir(portFullPath) and port[0] != '.':
                        print '\tPort: ' + port
                        for recipe in os.listdir(portFullPath):
                            recipeFullPath = portFullPath + '/' + recipe
                            if os.path.isfile(recipeFullPath) and \
                                recipe.endswith('.recipe'):
                                reWithVersion = re.compile(regExp['recipefilename'])
                                # reWithVersion = re.compile('^(?P<name>[a-z0-9\-_]*)-(?P<version>([\d]+[a-z\\.])*[\d]*)?$')

                                m = reWithVersion.match(recipe)
                                if (m and m.group('name') and
                                    m.group('version')):  # with version
                                    print('\t\tName/Version: %s\t%s' %
                                          (m.group('name'), m.group('version')))
                                    try:
                                        self.validateRecipeFile(recipeFullPath)
                                    except SystemExit:
                                        pass
                                else:
                                    # invalid argument
                                    print("Error: Couldn't parse port/version "
                                          "info: " + recipe)


# -- /etc/haikuports.conf and *.recipe parser -----------------------------------

class Config:
    def __init__(self, filename, keysAndTypes, shellVariables={}):
        self.options = {}

        # set up the shell environment -- we want it to inherit some of our
        # variables
        shellEnv = os.environ
        shellEnv.update(shellVariables)

        # execute the config file via the shell ....
        supportedKeysString = ' '.join(keysAndTypes.keys())
        wrapperScript = configFileEvaluatorScript % (filename, 
                                                     supportedKeysString)
        try:
            output = check_output(['/bin/bash', '-c', wrapperScript], 
                                      env=shellEnv)
        except (OSError, CalledProcessError):
            sys.exit("Error: Can't evaluate config file: " + filename)

        # ... and collect the resulting configurations (one per line)
        lines = output.splitlines()
        for line in lines:
            key, separator, valueString = line.partition('=')
            if not separator:
                sys.exit('Error: evaluating file %s produced illegal '
                         'key-values line:\n  %s\nexpected "<key>=<value>"\n'
                         'output of configuration script was:\n' 
                         % (filename, line, output))
                
            if key not in keysAndTypes:
                # skip unsupported key, just in case
                print 'Warning: key %s in file %s is unsupported, ignoring it' \
                    % (key, filename)
                continue
            
            valueString = valueString.replace(r'\n', '\n')
                # replace quoted newlines by real newlines
                
            type = keysAndTypes[key]
            if type == types.StringType:
                self.options[key] = valueString
            elif type == types.IntType:
                try:
                    self.options[key] = int(valueString)
                except ValueError:
                    sys.exit('Error: evaluating file %s produced illegal value '
                             '"%s" for key %s, expected an <integer> value'
                             % (filename, key, valueString))
            elif type == types.ListType:
                values = [v.strip() for v in valueString.splitlines()]
                self.options[key] = values
            elif type == PhaseType:
                if valueString.upper() not in PhaseType.getAllowedValues():
                    sys.exit('Error: evaluating file %s\nproduced illegal value '
                             '"%s" for key %s\nexpected one of: %s'
                             % (filename, key, valueString, 
                                ','.join(PhaseType.getAllowedValues())))
                self.options[key] = valueString.upper()
            elif type == StatusType:
                # treat as string for now
                self.options[key] = valueString.lower()
            else:
                sys.exit('Error: type of key %s in file %s is unsupported'
                         % (key, filename))
        # for key in self.options:
        #    print key + " = " + str(self.options[key])

    def getKeys(self):
        return self.options

    def valueOf(self, key):
        try:
            value = self.options[key]
            return value
        except KeyError:
            # an unspecified option is the same as an empty one
            return ''


# -- Command line argument parsing -------------------------------------------

parser =  OptionParser(usage='usage: %prog [options] portname[-portversion]',
                       version='%prog ' + info['version'])

parser.add_option('-l', '--list', action='store_true', dest='list',
                  default=False, help='list available ports')
parser.add_option('-a', '--about', action='store_true', dest='about',
                  default=False, help='show description of the specified port')
parser.add_option('-s', '--search', action='store_true', dest='search',
                  default=False, help='search for a port (regex)')
parser.add_option('-n', '--nopatch', action='store_false', dest='patch',
                  default=True, help="don't patch the sources, just download "
                                     "and unpack")
parser.add_option('-b', '--nobuild', action='store_false', dest='build',
                  default=True, help="don't build the port, just download, "
                                     "unpack and patch")
parser.add_option('-p', '--package', action='store_true', dest='package',
                  default=False, help="make distribution package of the "
                                      "specified port (include download, "
                                      "unpack, patch, build)")
parser.add_option('-c', '--clean', action='store_true', dest='clean',
                  default=False, help="clean the working directory of the "
                                      "specified port")
parser.add_option('-g', '--get', action='store_true', dest='get',
                  default=False, help="get/update the ports tree")
parser.add_option('-f', '--force', action='store_true', dest='force',
                  default=False, help="force to perform the steps (unpack, "
                                      "patch, build)")
parser.add_option('-z', '--archive', action='store_true', dest='archive',
                  default=False, help="Create a patched source archive as "
                                      "<package>_haiku.tar.xz")
parser.add_option('-t', '--tree', action='store_true', dest='tree',
                  default=False, help="print out the location of the "
                                      "haikuports source tree")
parser.add_option('-y', '--yes', action='store_true', dest='yes',
                  default=False, help="answer yes to all questions")
parser.add_option('-j', action='store', type="int", dest='jobs',
                  default=1, help="the number of concurrent jobs to build with")
parser.add_option('-o','--location', action='store_true', dest='location',
                default=False, help="print out the location of a recipe (via search) (for scripted editing)")
parser.add_option('--test', action='store_true', dest='test',
                  default=False, help="run tests on resulting binaries")
parser.add_option('--lint', action='store_true', dest='lint',
                  default=False, help="scan the ports tree for problems")

(options, args) = parser.parse_args()
haikuporter = HaikuPorter(options, args)
