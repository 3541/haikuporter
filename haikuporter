#!/bin/env python
# -*- coding: utf-8 -*-
# copyright 2007-2011 Brecht Machiels
# copyright 2009-2010 Chris Roberts
# copyright 2009-2011 Scott McCreary
# copyright 2009 Alexander Deynichenko
# copyright 2009 HaikuBot (aka RISC)
# copyright 2010-2011 Jack Laxson (Jrabbit)
# copyright 2011 Ingo Weinhold
# copyright 2013 Oliver Tappe

info = {}
info['version'] = 'r' + '$Rev$'[6:-2]

# -- Modules ------------------------------------------------------------------

import glob
import hashlib
import locale
from optparse import OptionParser
import os
import re
import shutil
from subprocess import check_call, PIPE, Popen, CalledProcessError
import sys
import tarfile
import time
import traceback
import types
import urllib2
import zipfile


# -- Modules preloaded for chroot ---------------------------------------------
# These modules need to be preloaded in order to avoid problems with python
# trying to dynamically load them inside a chroot environment
from encodings import string_escape


# -- HaikuPorts options -------------------------------------------------------

# location of haikuports.conf
haikuportsConf = '/etc/haikuports.conf'

svnPath = 'http://ports.haiku-files.org/svn/haikuports/trunk'

# -----------------------------------------------------------------------------

# Create new type 'ArchitecturesType' for identifying the port's status on each
# of the supported architectures.
# Within the string, support for an architecture can be specified like this:
#  'x86'  -> this port is known to work on the 'x86' architecture
#  '?x86' -> this port has not been built/tested on the 'x86' architecture yet,
#            it is expected to work, but that has not been verified
#  '!x86' -> this port is known to have problems on the 'x86' architecture
# An architecture missing from the status specification indicates that nothing
# is known about the status of the port on this architecture.
class ArchitecturesType(str):
    @staticmethod
    def getArchitectures():
        # TODO: fetch this from PackageKit?
        return [
            'any',
            'x86',
            'x86_gcc2',
        ]


# -----------------------------------------------------------------------------

# Allowed status for a port on a specific architecure
class Status(str):
    BROKEN = 'broken'
    STABLE = 'stable'
    UNSUPPORTED = 'unsupported'
    UNTESTED = 'untested'


# -----------------------------------------------------------------------------

# Create new type 'PhaseType' for identifying a port phase.
class PhaseType(str):
    @staticmethod
    def getAllowedValues():
        return [ 'BUILD', 'TEST', 'INSTALL' ]


# -----------------------------------------------------------------------------

# Create new type 'LinesOfText', used to handle the description in a recipe
class LinesOfText(list):
    pass


# -----------------------------------------------------------------------------

# allowed types of the /etc/haikuports.conf values
haikuportsConfigTypes = {}
haikuportsConfigTypes['PACKAGER'] = types.StringType
haikuportsConfigTypes['PATCH_OPTIONS'] = types.StringType
haikuportsConfigTypes['TREE_PATH'] = types.StringType

haikuportsConfigDefaults = {}  # [required, default]
haikuportsConfigDefaults['PACKAGER'] = [True, None]
haikuportsConfigDefaults['PATCH_OPTIONS'] = [False, None]
haikuportsConfigDefaults['TREE_PATH'] = [True, None]


# -----------------------------------------------------------------------------

# allowed types of the recipe-file values
recipeTypes = {}
recipeTypes['ARCHITECTURES'] = ArchitecturesType
recipeTypes['BUILD_PACKAGE_ACTIVATION_PHASE'] = PhaseType
recipeTypes['BUILD_PREREQUIRES'] = types.ListType
recipeTypes['BUILD_REQUIRES'] = types.ListType
recipeTypes['CHECKSUM_MD5'] = types.StringType
recipeTypes['CONFLICTS'] = types.ListType
recipeTypes['COPYRIGHT'] = types.ListType
recipeTypes['DESCRIPTION'] = LinesOfText
recipeTypes['FRESHENS'] = types.ListType
recipeTypes['HOMEPAGE'] = types.StringType
recipeTypes['LICENSE'] = types.ListType
recipeTypes['MESSAGE'] = types.StringType
recipeTypes['PROVIDES'] = types.ListType
recipeTypes['REPLACES'] = types.ListType
recipeTypes['REQUIRES'] = types.ListType
recipeTypes['REVISION'] = types.IntType
recipeTypes['SOURCE_DIR'] = types.StringType
recipeTypes['SRC_URI'] = types.ListType
recipeTypes['SUMMARY'] = types.StringType
recipeTypes['SUPPLEMENTS'] = types.ListType

recipeDefaults = {}  # [required, default]
recipeDefaults['ARCHITECTURES'] = [True, None]
recipeDefaults['BUILD_PACKAGE_ACTIVATION_PHASE'] = [False, PhaseType('BUILD')]
recipeDefaults['BUILD_PREREQUIRES'] = [False, []]
recipeDefaults['BUILD_REQUIRES'] = [False, []]
recipeDefaults['CHECKSUM_MD5'] = [False, None]
recipeDefaults['CONFLICTS'] = [False, []]
recipeDefaults['COPYRIGHT'] = [False, []]
recipeDefaults['DESCRIPTION'] = [True, None]
recipeDefaults['FRESHENS'] = [False, []]
recipeDefaults['HOMEPAGE'] = [True, None]
recipeDefaults['LICENSE'] = [False, []]
recipeDefaults['MESSAGE'] = [False, None]
recipeDefaults['PROVIDES'] = [True, None]
recipeDefaults['REPLACES'] = [False, []]
recipeDefaults['REQUIRES'] = [False, []]
recipeDefaults['REVISION'] = [True, 1]
recipeDefaults['SOURCE_DIR'] = [False, None]
recipeDefaults['SRC_URI'] = [True, []]
recipeDefaults['SUMMARY'] = [True, None]
recipeDefaults['SUPPLEMENTS'] = [False, []]
recipeDefaults['WORKING'] = [False, True]


# -----------------------------------------------------------------------------

# regex to split recipe filenames into port / version
regExp = {}
regExp['portname'] = '^(?P<name>[\w\-\+]+?)'
regExp['portversion'] = '(?P<version>[\w]*?[\d]+([\w\-\\.\+])*)'
regExp['portfullname'] = regExp['portname'] + '-' + regExp['portversion']
regExp['recipefilename'] = regExp['portfullname'] + '\.recipe$'


# -----------------------------------------------------------------------------

# Shell scriptlet that is used to execute a config file and output all the 
# configuration values (in the form of environment variables) which have been
# set explicitly in the configuration file. The first placeholder is substituted 
# with the configuration file, the second with a space separated list of 
# supported configuration keys.
# Note: this script requires bash, it won't work with any other shells
configFileEvaluatorScript = r'''# wrapper script for evaluating config/recipe

# stop on every error
set -e

# source the configuration file
. %s >/dev/null

# output all environment vars we are interested in and which have been set, 
# quoting any newlines in their values
NL=$'\n'
for key in %s 
do
    if [[ -n ${!key+dummy} ]]
    then
        value=${!key}
        echo "$key=${value//$NL/\\n}"
    fi
done
'''


# -----------------------------------------------------------------------------

# Shell scriptlet that is used to trigger one of the actions defined in a build
# recipe.The first placeholder is substituted with the configuration file, the 
# second one with the action to be invoked.
recipeActionScript = r'''# wrapper scriptlet for running an action

# stop on every error
set -e

# provide defaults for every action
BUILD()
{
    true
}

INSTALL()
{
    true
}

TEST()
{
    true
}

# source the configuration file
. %s >/dev/null

# invoke the requested action
action='%s'
if [[ $quiet ]]; then
    $action >/dev/null
else
    $action
fi
'''


# -----------------------------------------------------------------------------

# Shell scriptlet that prepares a chroot environment for entering.
# Invoked with $packages filled with the list of packages that should
# be activated (via common/packages) and $recipeFilePath pointing to the
# recipe file.
setupChrootScript = r'''

# stop on every error
set -e

mkdir -p \
    dev \
    boot/system/packages \
    boot/common/cache/tmp \
    boot/common/packages \
    boot/common/settings/etc \

ln -sfn /boot/system system
ln -sfn /boot/system/bin bin
ln -sfn /boot/system/package-links packages
ln -sfn /boot/common/cache/tmp tmp
ln -sfn /boot/common/settings/etc etc
ln -sfn /boot/common/var var

# remove any packages that may be lying around
rm -f boot/common/packages/*.hpkg
rm -f boot/system/packages/*.hpkg

# link all system packages
ln -s /boot/system/packages/*.hpkg boot/system/packages/

# link the list of required common packages
for pkg in $packages; do 
    ln -sfn "$pkg" boot/common/packages/
done

# copy recipe file and (optional) license & package directories into the chroot
cp $recipeFile port.recipe
if [ -d ../licenses ]; then
    cp -r ../licenses .
fi    
if [ -d ../patches ]; then
    cp -r ../patches .
fi    

# silently unmount if needed, just to be one the safe side
if [ -e dev/null ]; then
    unmount dev
fi
if [ -e boot/system/bin ]; then
    unmount boot/system
fi
if [ -e boot/common/bin ]; then
    unmount boot/common
fi

# mount dev, system-packagefs and common-packagefs
mount -t bindfs -p "source /dev" dev
mount -t packagefs -p "type system" boot/system
mount -t packagefs -p "type common" boot/common
'''


# -----------------------------------------------------------------------------

# Shell scriptlet that cleans up a chroot environment after it has been exited.
# Invoked with $buildOk indicating if the build has worked and thus all paths 
# required for building only should be wiped.
cleanupChrootScript = r'''

# try to make sure we really are in a work directory
if ! echo $(basename $PWD) | grep -qE '^work-'; then 
    echo "cleanupChroot invoked in $PWD, which doesn't seem to be a work dir!"
    exit 1
fi

unmount dev
unmount boot/system
unmount boot/common

# wipe files and directories if it is ok to do so
if [[ $buildOk ]]; then
    echo "cleaning chroot folder"
    rmdir dev
    rm -rf \
        boot \
        licenses \
        packages \
        repository \
        system
    rm -f \
        .PackageInfo \
        bin \
        etc \
        port.recipe \
        tmp \
        var
else
    echo "keeping chroot folder $PWD intact for inspection"
fi
'''


# -- global configuration ----------------------------------------------------
haikuportsConfig = {}


# -- capture output of shell command -----------------------------------------
def check_output(*popenargs, **kwargs):
    """local clone of subprocess.check_output() provided by python-2.7
       TODO: drop this once we have upgraded python to 2.7"""
    process = Popen(stdout=PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        raise CalledProcessError(retcode, cmd)
    return output


# -- Set up locale for thousands seperators ----------------------------------
def _ourLocaleconv(lc=locale.localeconv()):
    lc.update({'thousands_sep': ',', 'grouping': [3, 3, 0]})
    return lc

locale.localeconv = _ourLocaleconv


# -- wraps invocation of sys.exit() ------------------------------------------
def sysExit(message):
    message = '\n'.join(['*** ' + line for line in message.split('\n') ])
    sys.exit(message)


# -- prints a warning --------------------------------------------------------
def warn(message):
    message = '\n'.join(['* ' + line for line in message.split('\n') ])
    print(message)


# -- wraps invocation of 'finddir' -------------------------------------------
def findDirectory(aDir):
    return check_output(['/bin/finddir', aDir]).rstrip()  # drop newline


# ----------------------------------------------------------------------------

# Frequently used directories
systemDir = {
	'B_COMMON_DIRECTORY': None,
	'B_COMMON_PACKAGES_DIRECTORY': None,
	'B_PACKAGE_LINKS_DIRECTORY': None,
	'B_SYSTEM_DIRECTORY': None,
	'B_SYSTEM_PACKAGES_DIRECTORY': None,
}
for key in systemDir.keys():
    systemDir[key] = findDirectory(key)


# -- Scoped resource for chroot environments ---------------------------------
class ChrootSetup:
    def __init__(self, chrootPath, packagesToBeActivated, recipeFilePath):
        self.path = chrootPath
        self.packages = packagesToBeActivated
        self.recipeFile = recipeFilePath
        self.buildOk = False

    def __enter__(self):
        # execute the chroot setup scriptlet via the shell ...
        os.chdir(self.path)
        shellEnv = { 
            'packages': '\n'.join(self.packages), 
            'recipeFile': self.recipeFile, 
        }
        check_call(['/bin/bash', '-c', setupChrootScript], env=shellEnv)
        return self
    
    def __exit__(self, type, value, traceback):
        # execute the chroot cleanup scriptlet via the shell ...
        os.chdir(self.path)
        shellEnv = {}
        if self.buildOk:
            shellEnv['buildOk'] = '1'
        check_call(['/bin/bash', '-c', cleanupChrootScript], env=shellEnv)


# -- Scoped resource for a temporarily renamed file --------------------------
class TemporarilyRenamedFile:
    def __init__(self, file):
        self.file = file
        self.fileName = os.path.basename(file)
        self.subDir = None

    def __enter__(self):
        # rename the file
        self.subDir = os.path.dirname(self.file) + '/deactivated'
        if not os.path.exists(self.subDir):
            os.mkdir(self.subDir)
        os.rename(self.file, self.subDir + '/' + self.fileName)
        return self
    
    def __exit__(self, type, value, traceback):
        # restore the original file
        if self.subDir:
            os.rename(self.subDir + '/' + self.fileName, self.file)
            os.rmdir(self.subDir)


# -- A package which can be created from a port ------------------------------
class Package:
    def __init__(self, name, fileName, fullPath):
        self.name = name
        self.version = version
        self.versionedName = name + '-' + version
        self.baseDir = baseDir
        self.architecture = globalShellVariables['architecture']
        

# -- A single port with its recipe, allows to execute actions ----------------
class Port:
    def __init__(self, name, version, category, baseDir, globalShellVariables):
        self.name = name
        self.version = version
        self.versionedName = name + '-' + version
        self.category = category            
        self.baseDir = baseDir
        self.architecture = globalShellVariables['architecture']
        self.recipeFilePath \
            = self.baseDir + '/' + self.name + '-' + self.version + '.recipe'
        
        self.packageInfoName = self.versionedName + '.PackageInfo'
        
        self.forceOverride = False
        self.beQuiet = False
        self.avoidChroot = False

        self.revision = None
        self.fullVersion = None
        self.revisionedName = None
        self.buildPackage = None
        self.activeBuildPackage = None

        # build dictionary of variables to inherit to shell
        self.shellVariables = {
            'portName': self.name,
            'portVersion': self.version,
            'portVersionedName': self.versionedName,
        }
        self.shellVariables.update(globalShellVariables)
        
        # Each port creates at least one package (which will share its name).
        # If additional packages are declared in the recipe, they will be 
        # added here, later.
        self.packages = [
            {
        		'name': name,
            }
        ]

        # create full paths for the directories
        self.downloadDir = self.baseDir + '/download'
        self.patchesDir = self.baseDir + '/patches'
        self.workDir = self.baseDir + '/work-' + self.version
        self.sourceDir = self.sourceBaseDir = self.workDir + '/sources'
        self.packagingDir = self.workDir + '/packaging'

    def __enter__(self):
        return self
    
    def __exit__(self, type, value, traceback):
        pass

    def parseRecipeFile(self):
        """Parse the recipe-file of the specified port"""
        self.validateRecipeFile()

        # set default values when not provided
        for key in recipeDefaults:
            if key not in self.recipeKeys:
                self.recipeKeys[key] = recipeDefaults[key][1]
                
        # initialize variables that depend on the recipe revision
        self.revision = str(self.recipeKeys['REVISION'])
        self.fullVersion = self.version + '-' + self.revision
        self.revisionedName = self.name + '-' + self.fullVersion
        self.packages[0]['filename'] \
            = self.revisionedName + '-' + self.architecture + '.hpkg'
        self.packages[0]['fullPath'] \
            = self.workDir + '/' + self.packages[0]['filename']

        # If a SOURCE_DIR was specified, adjust the default
        if self.recipeKeys['SOURCE_DIR']:
            self.sourceDir = (self.sourceBaseDir + '/' + 
                              self.recipeKeys['SOURCE_DIR'])

        # set up the complete list of variables we'll inherit to the shell
        # when executing a recipe action
        self._initShellVariablesFromRecipe()

        # for key in self.recipeKeys:
        #     print key + " = " + str(self.recipeKeys[key])

    def validateRecipeFile(self):
        """Validate the syntax and contents of the recipe file"""
        
        if not os.path.exists(self.recipeFilePath):
            sysExit(self.name + ' version ' + self.version + ' not found.')

        recipeConfig = Config(self.recipeFilePath, recipeTypes, 
                              self.shellVariables)
        self.recipeKeys = recipeConfig.getEntries()

        # check whether all required fields are present
        for key in recipeDefaults:
            if key not in self.recipeKeys and recipeDefaults[key][0]:
                sysExit("Required field '" + key + "' not present (in %s)" 
                        % self.recipeFilePath)

        # The summary must be a single line of text, preferably not exceeding
        # 70 characters in length
        if '\n' in self.recipeKeys['SUMMARY']:
            sysExit('SUMMARY must be a single line of text (%s).' 
                    % self.recipeFilePath)
        if len(self.recipeKeys['SUMMARY']) > 70:
            warn('SUMMARY exceeds 70 chars (in %s)' % self.recipeFilePath)

        # Check for a valid license file
        if 'LICENSE' in self.recipeKeys:
            fileList = []
            recipeLicense = self.recipeKeys['LICENSE']
            for item in recipeLicense:
                dirname = systemDir['B_SYSTEM_DIRECTORY'] + '/data/licenses'
                haikuLicenseList = fileList = os.listdir(dirname)
                if item not in fileList:
                    fileList = []
                    dirname \
                        = os.path.dirname(self.recipeFilePath) + '/licenses'
                    if os.path.exists(dirname):
                        for filename in os.listdir(dirname):
                            fileList.append(filename)
                if item not in fileList:
                    haikuLicenseList.sort()
                    sysExit(('No match found for License %s \n' % item) + '\n'
                            + 'Valid license filenames included with Haiku '
                            + 'are:\n\n' + '\n'.join(haikuLicenseList))

        if 'LICENSE' not in self.recipeKeys or not self.recipeKeys['LICENSE']:
            warn('No LICENSE found (in %s)' % self.recipeFileName)

        if ('COPYRIGHT' not in self.recipeKeys 
            or not self.recipeKeys['COPYRIGHT']):
            warn('No COPYRIGHT found (in %s)' % self.recipeFileName)

    def printDescription(self):
        """Show port description"""
        print '*' * 80
        print 'SUMMARY: %s' % self.recipeKeys['SUMMARY']
        print 'DESCRIPTION: %s' % self.recipeKeys['DESCRIPTION']
        print 'HOMEPAGE: %s' % self.recipeKeys['HOMEPAGE']
        print '*' * 80

    def getStatusOnCurrentArchitecture(self):
        """Return the status of this port on the current architecture"""
        if self.architecture in self.recipeKeys['ARCHITECTURES']:
            return self.recipeKeys['ARCHITECTURES'][self.architecture]
        return Status.UNSUPPORTED
    
    def resolveBuildDependencies(self, repositoryPath, packagesPath):
        """Resolve any other ports that need to be built before this one,
           in this case including the build_requires as well as the requires.
        """

        packageInfoFile = repositoryPath + '/' + self.packageInfoName
        try:
            output = check_output([
                '/bin/pkgman', 'resolve-dependencies', 
                packageInfoFile, packagesPath, repositoryPath,
                systemDir['B_COMMON_PACKAGES_DIRECTORY'], 
                systemDir['B_SYSTEM_PACKAGES_DIRECTORY']])
            return output.splitlines();
        except CalledProcessError as e:
            sysExit('unable to resolve dependencies for ' + self.versionedName)

    def resolveStrictBuildDependencies(self, repositoryPath, packagesPath):
        """Resolve any other ports that need to be built before this one,
           in this case strictly using build-requires only"""

        # create work dir if needed
        if not os.path.exists(self.workDir):
            os.makedirs(self.workDir)

        shadowedPackageInfo = repositoryPath + '/' + self.packageInfoName
        with TemporarilyRenamedFile(shadowedPackageInfo):
            # Generate a PackageInfo-file containing only the immediate 
            # requirements for building this port:
            packageInfoFile = self.workDir + '/.PackageInfo'
            self._generatePackageInfo(packageInfoFile, 
                                      [ 'BUILD_REQUIRES' ], 
                                      True)

            try:
                output = check_output([
                    '/bin/pkgman', 'resolve-dependencies', 
                    packageInfoFile, packagesPath, repositoryPath,
                    systemDir['B_COMMON_PACKAGES_DIRECTORY'], 
                    systemDir['B_SYSTEM_PACKAGES_DIRECTORY']])
                return output.splitlines();
            except CalledProcessError as e:
	            sysExit('unable to resolve dependencies for ' 
	                    + self.versionedName)

    def writePackageInfoIntoRepository(self, repositoryPath):
        """Write the PackageInfo-file into the repository"""

        if not self.revision:
            self.parseRecipeFile()
            
        packageInfoFile = repositoryPath + '/' + self.packageInfoName
        self._generatePackageInfo(packageInfoFile, 
                                  [ 'BUILD_REQUIRES', 'REQUIRES' ], True)
                    
    def cleanWorkDirectory(self):
        """Clean the working directory"""
        if os.path.exists(self.workDir):
            print 'Cleaning work directory...'
            shutil.rmtree(self.workDir)
                
    def downloadSource(self):
        """Fetch the source archive"""
        for src_uri in self.recipeKeys['SRC_URI']:
            # Examine the URI to determine if we need to perform a checkout
            # instead of download
            if re.match('^cvs.*$|^svn.*$|^hg.*$|^git.*$|^bzr.*$|^fossil.*$',
                        src_uri):
                self.checkoutSource(src_uri)
                return

            try:
                # Need to make a request to get the actual uri in case it is an
                # http redirect
                uri_request = urllib2.urlopen(src_uri)
                src_uri = uri_request.geturl()

                self.src_local = src_uri[src_uri.rindex('/') + 1:]
                fp = self.downloadDir + '/' + self.src_local
                if os.path.isfile(fp):
                    print 'Skipping download ...'
                    return
                else:
                    # create download dir and cd into it
                    if not os.path.exists(self.downloadDir):
                        os.mkdir(self.downloadDir)

                    os.chdir(self.downloadDir)

                    print '\nDownloading: ' + src_uri
                    check_call(['wget', '-c', '--tries=3', src_uri])

                    # succesfully downloaded source archive
                    return
            except Exception:
                warn('Download error, trying next location.')

        # failed to fetch source
        sysExit('Failed to download source package from all locations.')

    def checkoutSource(self, uri):
        """Parse the URI and execute the appropriate command to check out the
           source.
        """
        if self.checkFlag('checkout') and not self.forceOverride:
            print 'Source already checked out. Skipping ...'
            return

        # If the work dir exists we need to clean it out
        if os.path.exists(self.workDir):
            shutil.rmtree(self.workDir)

        print 'Source checkout: ' + uri

        # Attempt to parse a URI with a + in it. ex: hg+http://blah
        # If it doesn't find the 'type' it should extract 'real_uri' and 'rev'
        m = re.match('^((?P<type>\w*)\+)?(?P<real_uri>.+?)(#(?P<rev>.+))?$',
                     uri)
        if not m or not m.group('real_uri'):
            sysExit("Couldn't parse repository URI " + uri)

        type = m.group('type')
        real_uri = m.group('real_uri')
        rev = m.group('rev')

        # Attempt to parse a URI without a + in it. ex: svn://blah
        # TODO improve the regex above to fallback to this pattern
        if not type:
            m = re.match("^(\w*).*$", real_uri)
            if m:
                type = m.group(1)

        if not type:
            sysExit("Couldn't parse repository type from URI " + real_uri)

        # Set the name of the directory to check out sources into
        checkoutDir = self.name + '-' + self.version

        # Start building the command to perform the checkout
        if type == 'cvs':
            # Chop off the leading cvs:// part of the uri
            real_uri = real_uri[real_uri.index('cvs://') + 6:]

            # Extract the cvs module from the uri and remove it from real_uri
            module = real_uri[real_uri.rfind('/') + 1:]
            real_uri = real_uri[:real_uri.rfind('/')]
            checkoutCommand = 'cvs -d' + real_uri + ' co -P'
            if rev:
                # For CVS 'rev' specifies a date
                checkoutCommand += ' -D' + rev
            checkoutCommand += ' -d ' + checkoutDir + ' ' + module
        elif type == 'svn':
            checkoutCommand \
                = 'svn co --non-interactive --trust-server-cert'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'hg':
            checkoutCommand = 'hg clone'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'bzr':
            # http://doc.bazaar.canonical.com/bzr-0.10/bzr_man.htm#bzr-branch-from-location-to-location
            checkoutCommand = 'bzr checkout --lightweight'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'fossil':
            # http://fossil-scm.org/index.html/doc/trunk/www/quickstart.wiki
            if os.path.exists(checkoutDir + '.fossil'):
                shutil.rmtree(checkoutDir + '.fossil')
            checkoutCommand = 'fossil clone ' + real_uri
            checkoutCommand += ' ' + checkoutDir + '.fossil'
            checkoutCommand += ' && '
            checkoutCommand += 'mkdir -p ' + checkoutDir
            checkoutCommand += ' && '
            checkoutCommand += 'fossil open ' + checkoutDir + '.fossil'
            if rev:
                checkoutCommand += ' ' + rev
        else:
            # TODO Skip the initial checkout if a rev is specified?
            checkoutCommand = 'git clone %s %s' % (real_uri, checkoutDir)
            if rev:
                checkoutCommand += (' && cd %s'
                                    ' && git checkout %s' % (checkoutDir, rev))

        # create the source-base dir
        if not os.path.exists(self.sourceBaseDir):
            os.makedirs(self.sourceBaseDir)

        check_call(checkoutCommand, shell=True, cwd=self.sourceBaseDir)

        # Set the 'checkout' flag to signal that the checkout is complete
        # This also tells haikuporter not to attempt an unpack step
        self.setFlag('checkout')

    def checksumSource(self):
        if self.recipeKeys['CHECKSUM_MD5']:
            print 'Checking MD5 checksum of download ...'
            h = hashlib.md5()
            f = open(self.downloadDir + '/' + self.src_local, 'rb')
            while True:
                d = f.read(16384)
                if not d:
                    break
                h.update(d)
            f.close()
            if h.hexdigest() != self.recipeKeys['CHECKSUM_MD5']:
                sysExit('Expected: ' + self.recipeKeys['CHECKSUM_MD5'] + '\n'
                        + 'Found: ' + h.hexdigest())
        else:
            # The checkout flag only gets set when a source checkout is 
            # performed. If it exists we don't need to warn about the missing 
            # recipe field
            if not self.checkFlag('checkout'):
                warn('CHECKSUM_MD5 key not found in recipe file.')

    def unpackSource(self):
        """Unpack the source archive (into the work directory)"""

        # If the source came from a vcs there is no unpack step
        if self.checkFlag('checkout'):
            return

        # create source-base dir
        if not os.path.exists(self.sourceBaseDir):
            os.makedirs(self.sourceBaseDir)

        # Check to see if the source archive was already unpacked.
        if self.checkFlag('unpack') and not self.forceOverride:
            print 'Skipping unpack ...'
            return

        # unpack source archive
        print 'Unpacking ' + self.src_local
        archiveFullPath = self.downloadDir + '/' + self.src_local
        if tarfile.is_tarfile(archiveFullPath):
            tf = tarfile.open(self.downloadDir + '/' + self.src_local, 'r')
            tf.extractall(self.sourceBaseDir)
            tf.close()
        elif zipfile.is_zipfile(archiveFullPath):
            zf = zipfile.ZipFile(self.downloadDir + '/' + self.src_local, 'r')
            zf.extractall(self.sourceBaseDir)
            zf.close()
        elif archiveFullPath.split('/')[-1].split('.')[-1] == 'xz':
            Popen(['xz', '-d', '-k', archiveFullPath]).wait()
            tar = archiveFullPath[:-3]
            if tarfile.is_tarfile(tar):
                tf = tarfile.open(tar, 'r')
                tf.extractall(self.sourceBaseDir)
                tf.close()
        else:
            sysExit('Unrecognized archive type in file ' + self.src_local)

        self.setFlag('unpack')

    def patchSource(self):
        """Apply the Haiku patches to the source directory"""
        # Check to see if the patch was already applied to the source.
        if self.checkFlag('patch') and not self.forceOverride:
            return

        patchFilePath = self.patchesDir + '/' + self.name + '-'\
             + self.version + '.patch'
        if os.path.exists(patchFilePath):
            print 'Patching ...'
            patchOptions = ''
            if 'PATCH_OPTIONS' in haikuportsConfig:
                patchOptions += haikuportsConfig['PATCH_OPTIONS']
            check_call('patch -p0 ' + patchOptions + ' -i '
                        + patchFilePath, shell=True, cwd=self.sourceBaseDir)
        else:
            print 'No patching required'
        self.setFlag('patch')

    def build(self, packagesPath, makePackages):
        """Build the port and collect the resulting package"""

        packageInfoFile = self.workDir + '/.PackageInfo'
        self._generatePackageInfo(packageInfoFile, 
                                  [ 'BUILD_REQUIRES', 'BUILD_PREREQUIRES' ], 
                                  True, True)

        requiredPackages = self._getPackagesRequiredForBuild(packageInfoFile, 
                                                             packagesPath)

        if self.avoidChroot:
            self._executeBuild(makePackages)
        else:
            # setup chroot and keep it while executing the actions
            with ChrootSetup(self.workDir, requiredPackages, 
                             self.recipeFilePath) as chrootSetup:
                pid = os.fork()
                if pid == 0:
                    # child, enter chroot and execute the build
                    try:
                        os.chroot(self.workDir)
                        self._adjustToChroot()
                        self._executeBuild(makePackages)
                    except:
                        traceback.print_exc()
                        os._exit(1)
                    os._exit(0)

                # parent, wait on child
                if os.waitpid(pid, 0)[1] != 0:
                    sysExit('Build has failed - stopping.')
                
                # tell the shell scriptlets that the build has succeeded
                chrootSetup.buildOk = True

        if makePackages:                    
            # move all created packages into packages folder
            for package in self.packages:
                if os.path.exists(package['fullPath']):
                    print 'grabbing ' + package['filename']
                    os.rename(package['fullPath'], 
                              packagesPath + '/' + package['filename'])

    def setFlag(self, name):
        open('%s/flag.%s' % (self.workDir, name), 'w').close()

    def unsetFlag(self, name):
        flagFile = '%s/flag.%s' % (self.workDir, name)
        if os.path.exists(flagFile):
            os.remove(flagFile)

    def checkFlag(self, name):
        return os.path.exists('%s/flag.%s' % (self.workDir, name))

    def test(self):
        """Test the port"""
        
        # TODO!

    def makePatchedArchive(self):
        """Create a patched source archive"""
        print 'Creating patched source archive ...'

        # Set the path and filename for the archive.
        date = time.strftime('-%Y-%m-%d', time.localtime())
        archiveFile = self.baseDir + '/' + self.name + '-'\
             + self.version + '_haiku' + date + '.tar.xz'

        sourceFiles = ''

        # Build the list of dirs to archive.
        # Since we don't know the name we have to iterate over the dir.
        for f in os.listdir(self.sourceBaseDir):
            if os.path.isdir(self.sourceBaseDir + '/' + f):
                sourceFiles += ' ' + f

        # Make sure we found something to archive
        if not sourceFiles:
            sysExit('No source directories found in work dir.')

        # Archive the package and save it in the root of the port dir.
        check_call('tar cJvf ' + archiveFile + ' ' + sourceFiles,
                   shell=True, cwd=self.sourceBaseDir)

        # Clean up after ourselves
        shutil.rmtree(self.workDir)

        print 'Archive saved to: ' + archiveFile

    def _initShellVariablesFromRecipe(self):
        """Fill dictionary with variables that will be inherited to the shell
           when executing recipe actions
        """
        prefix = systemDir['B_PACKAGE_LINKS_DIRECTORY'] + '/' \
            + self.revisionedName + '/.self'

        self.shellVariables.update({
            'portRevision': self.revision,
            'portFullVersion': self.fullVersion,
            'portRevisionedName': self.revisionedName,
            'sourceDir': self.sourceDir,
        })

        configureDirs = {
            'prefix': prefix,
            'dataRootDir': prefix + '/data',
            'binDir': prefix + '/bin',
            'sbinDir': prefix + '/bin',
            'libDir': prefix + '/lib',
            'includeDir': prefix + '/develop/headers',
            'sysconfDir': prefix + '/settings',
            'docDir': prefix + '/documentation/packages/' + self.name,
            'infoDir': prefix + '/documentation/info',
            'manDir': prefix + '/documentation/man',
        }
        self.shellVariables.update(configureDirs)

        # add one more variable containing all the dir args for configure:
        self.shellVariables['configureDirArgs'] \
            = ' '.join(['--%s=%s' % (k.lower(), v) 
                       for k, v in configureDirs.iteritems()])

    def _getPackagesRequiredForBuild(self, packageInfoFile, packagesPath):
        """Determine the set of packages that must be linked into the 
           build environment (chroot) for the build stage"""
        
        try:
            args = ['/bin/pkgman', 'resolve-dependencies', 
                    packageInfoFile, packagesPath,
                    systemDir['B_COMMON_PACKAGES_DIRECTORY'], 
                    systemDir['B_SYSTEM_PACKAGES_DIRECTORY']]
            output = check_output(args)
            return output.splitlines();
        except CalledProcessError as e:
            try:
                output = check_call(args)
            except:
                pass
            sysExit('unable to resolve dependencies for ' + self.versionedName)

    def _executeBuild(self, makePackages):
        """Executes the build stage and creates all declared packages"""
        self._createBuildPackage()
        self._doBuildStage()
        if makePackages:
            for package in self.packages:
                self._makePackage(package)
        if self.activeBuildPackage and os.path.exists(self.activeBuildPackage):
            os.remove(self.activeBuildPackage)
        if self.buildPackage and os.path.exists(self.buildPackage):
            os.remove(self.buildPackage)

    def _adjustToChroot(self):
        """Adjust directories to chroot()-ed environment"""
        
        # unset directories which can't be reached from inside the chroot
        self.baseDir = None
        self.downloadDir = None
        
        # the recipe file has a fixed same name in the chroot
        self.recipeFilePath = '/port.recipe'

        # adjust all relevant directories
        pathLengthToCut = len(self.workDir)
        self.sourceDir = self.sourceDir[pathLengthToCut:]
        self.sourceBaseDir = self.sourceBaseDir[pathLengthToCut:]
        self.packagingDir = self.packagingDir[pathLengthToCut:]
        self.workDir = ''
        self.patchesDir = '/patches'

        # adjust all package file paths
        for package in self.packages:
            package['fullPath'] = package['fullPath'][pathLengthToCut:]
                
    def _doBuildStage(self):
        """Run the actual build"""
        # activate build package if required at this stage
        if self.recipeKeys['BUILD_PACKAGE_ACTIVATION_PHASE'] == 'BUILD':
            self._activateBuildPackage()
            
        # Check to see if a previous build was already done.
        if self.checkFlag('build') and not self.forceOverride:
            print 'Skipping build ...'
            return

        # Delete and re-create the packaging dir -- the port's build may need
        # to use it.
        if os.path.exists(self.packagingDir):
            shutil.rmtree(self.packagingDir, True)
        os.mkdir(self.packagingDir)

        print 'Building ...'
        self._doRecipeAction('BUILD', self.sourceDir)
        self.setFlag('build')

    def _makePackage(self, package):
        """Create a package suitable for distribution"""
        print 'Creating distribution package ' + package['name'] + ' ...'

        # recreate empty packaging directory
        shutil.rmtree(self.packagingDir, True)
        os.mkdir(self.packagingDir)

        if os.path.exists('/licenses'):
            shutil.copytree('/licenses', self.packagingDir + '/data/licenses')

        self._doInstallStage()
        
        self._generatePackageInfo(self.packagingDir + '/.PackageInfo', 
                                  ['REQUIRES'], self.beQuiet)

        if os.path.exists(package['fullPath']):
            os.remove(package['fullPath'])
        
        # Create the package
        print 'creating package ' + package['filename'] + ' ...'
        os.chdir(self.packagingDir)
        check_call(['package', 'create', package['fullPath']])

        # Clean up after ourselves
        shutil.rmtree(self.packagingDir)

        # give hint about source package for ports using (L)GPL license
        if 'GNU GPL' in self.recipeKeys['LICENSE'] \
            or 'GNU LGPL' in self.recipeKeys['LICENSE']:
            print ('To generate the matching source package, run: '
                   'haikuporter -z ' + self.name + '-' + self.version)

    def _doInstallStage(self):
        """Install the files resulting from the build into the packaging 
           folder"""
        # activate build package if required at this stage
        if self.recipeKeys['BUILD_PACKAGE_ACTIVATION_PHASE'] == 'INSTALL':
            self._activateBuildPackage()
            
        print 'Collecting files to be packaged ...'
        self._doRecipeAction('INSTALL', self.sourceDir)

    def _doTestStage(self):
        """Test the build results"""
        print 'Testing ...'
        self._doRecipeAction('TEST', self.sourceDir)

    def _doRecipeAction(self, action, dir):
        """Run the specified action, as defined in the recipe file"""
        # set up the shell environment -- we want it to inherit some of our
        # variables
        shellEnv = os.environ
        shellEnv.update(self.shellVariables)

        # execute the requested action via a shell ....
        wrapperScript = recipeActionScript % (self.recipeFilePath, action)
        check_call(['/bin/bash', '-c', wrapperScript], cwd=dir, env=shellEnv)

    def _createBuildPackage(self):
        """Create and activate the build package"""
        # create a package info for a build package
        buildPackageInfo \
            = self.workDir + '/' + self.revisionedName + '-build-package-info'
        self._generatePackageInfo(
            buildPackageInfo, 
            ['REQUIRES', 'BUILD_REQUIRES', 'BUILD_PREREQUIRES'], True)

        # create the build package
        buildPackage \
            = self.workDir + '/' + self.revisionedName + '-build.hpkg'
        cmdlineArgs = ['package', 'create', '-bi', buildPackageInfo, '-I',
                       self.packagingDir, buildPackage]
        if self.beQuiet:
            cmdlineArgs.insert(2, '-q')
        check_call(cmdlineArgs)
        self.buildPackage = buildPackage
        os.remove(buildPackageInfo)

    def _activateBuildPackage(self):
        """Activate the build package"""
        # activate the build package
        packagesDir = systemDir['B_COMMON_PACKAGES_DIRECTORY']
        activeBuildPackage \
            = packagesDir + '/' + os.path.basename(self.buildPackage)
        if os.path.exists(activeBuildPackage):
            os.remove(activeBuildPackage)
            
        if self.avoidChroot:
            # may have to cross devices, so better use a symlink
            os.symlink(self.buildPackage, activeBuildPackage)
        else:
            # symlinking a package won't work in chroot, but in this
            # case we are sure that the move won't cross devices
            os.rename(self.buildPackage, activeBuildPackage)
        self.activeBuildPackage = activeBuildPackage

    def _generatePackageInfo(self, packageInfoPath, requiresToUse, quiet,
                             fakeEmptyProvides=False):
        """Create a .PackageInfo file for inclusion in a package"""
        
        with open(packageInfoPath, 'w') as infoFile:
            if fakeEmptyProvides:
                infoFile.write('name\t\t\tfaked_' + self.name + '\n')
            else:
                infoFile.write('name\t\t\t' + self.name + '\n')
            infoFile.write('version\t\t\t' + self.fullVersion + '\n')
            infoFile.write('architecture\t\t' + self.architecture + '\n')
            infoFile.write('summary\t\t\t"' + self.recipeKeys['SUMMARY'] 
                           + '"\n')
    
            infoFile.write('description\t\t"')
            infoFile.write('\n'.join(self.recipeKeys['DESCRIPTION']))
            infoFile.write('"\n')
    
            infoFile.write('packager\t\t"' + haikuportsConfig['PACKAGER'] 
                           + '"\n')
            infoFile.write('vendor\t\t\t"Haiku Project"\n')
    
            # These keys aren't mandatory so we need to check if they exist
            if self.recipeKeys['LICENSE']:
                infoFile.write('licenses {\n')
                for license in self.recipeKeys['LICENSE']:
                    infoFile.write('\t"' + license + '"\n')
                infoFile.write('}\n')
    
            if self.recipeKeys['COPYRIGHT']:
                infoFile.write('copyrights {\n')
                for copyright in self.recipeKeys['COPYRIGHT']:
                    infoFile.write('\t"' + copyright + '"\n')
                infoFile.write('}\n')
    
            requires = []
            for requiresKey in requiresToUse:
                requires += self.recipeKeys[requiresKey]
    
            if fakeEmptyProvides:
                infoFile.write('provides {\n\tfaked_' + self.name + ' = ' 
                               + self.version + '\n}\n')
            else:
                self._writePackageInfoListByKey(infoFile, 'PROVIDES', 
                                                'provides')
            self._writePackageInfoList(infoFile, requires, 'requires')
            self._writePackageInfoListByKey(infoFile, 'SUPPLEMENTS', 
                                            'supplements')
            self._writePackageInfoListByKey(infoFile, 'CONFLICTS', 'conflicts')
            self._writePackageInfoListByKey(infoFile, 'FRESHENS', 'freshens')
            self._writePackageInfoListByKey(infoFile, 'REPLACES', 'replaces')
    
            infoFile.write('urls\t\t\t"' + self.recipeKeys['HOMEPAGE'] + '"\n')
    
            # Generate SourceURL lines for all ports, regardless of license.
            # Re-use the download URLs, as specified in the recipe.
            infoFile.write('source-urls {\n')
            uricount = 1
            for src_uri in self.recipeKeys['SRC_URI']:
                if uricount < 2:
                    infoFile.write('\t"Download <' + src_uri + '>"\n')
                else:
                    infoFile.write('\t"Location ' + str(uricount) + ' <' 
                                   + src_uri + '>"\n')
                uricount += 1
    
            # Point directly to the file in subversion.
            recipeurl_base = ('http://ports.haiku-files.org/'
                              + 'svn/haikuports/trunk/' + self.category + '/' 
                              + self.name)
    
            recipeurl = (recipeurl_base + '/' + self.name+ '-' + self.version 
                         + '.recipe')
    
            infoFile.write('\t"Port-file <' + recipeurl + '>"\n')
            patchFilePath = (self.patchesDir + '/' + self.name + '-' 
                             + self.version + '.patch')
            if os.path.exists(patchFilePath):
                patchurl = (recipeurl_base + '/patches/' + self.name + '-'
                            + self.version + '.patch')
                infoFile.write('\t"Patches <' + patchurl + '>"\n')
    
            infoFile.write('}\n')
        
        if not quiet:
            with open(packageInfoPath, 'r') as infoFile:
                infoFileDisplay = infoFile.read()
                print infoFileDisplay

    def _writePackageInfoListByKey(self, infoFile, key, keyword):
        self._writePackageInfoList(infoFile, self.recipeKeys[key], keyword)

    def _writePackageInfoList(self, infoFile, list, keyword):
        if list:
            infoFile.write(keyword + ' {\n')
            for item in list:
                infoFile.write('\t' + item + '\n')
            infoFile.write('}\n')


# -- Main Class --------------------------------------------------------------
class HaikuPorter:
    def __init__(self, options, args):
        self.options = options
        
        # read global settings
        global haikuportsConfig
        haikuportsConfig = Config(haikuportsConf, 
                                  haikuportsConfigTypes).getEntries()

        # check whether all required fields are present
        for key in haikuportsConfigDefaults:
            if (key not in haikuportsConfig 
                    and haikuportsConfigDefaults[key][0]):
                sysExit("Required field '" + key + "' not present in " 
                        + haikuportsConf)

        # set up the global variables we'll inherit to the shell
        self._initGlobalShellVariables()
    
        self.treePath = haikuportsConfig['TREE_PATH'].rstrip('/')
        
        # create path where built packages will be collected
        self.packagesPath = self.treePath + '/packages'
        if not os.path.exists(self.packagesPath):
            os.mkdir(self.packagesPath)

        # the path where repository will be built
        self.repositoryPath = self.treePath + '/repository'

        # if requested, list all ports in the HaikuPorts tree
        if self.options.list:
            self._searchPorts(None)
            sys.exit()

        # if requested, search for a port
        if self.options.search:
            if not args:
                sysExit('You need to specify a search string.\n'
                        "Invoke '" + sys.argv[0] + " -h' for usage "
                        "information.")
            self._searchPorts(args[0])
            sys.exit()
        
        if self.options.location:
            if not args:
                sysExit('You need to specify a search string.\n'
                        "Invoke '" + sys.argv[0] + " -h' for usage "
                        "information.")
            # Provide the installed location of a port (for quick editing)
            print os.path.join(self.treePath, self.searchPorts(args[0]))
            sys.exit()

        # if requested, checkout or update ports tree
        if self.options.get:
            self._updatePortsTree()
            sys.exit()

        # if requested, print the location of the haikuports source tree
        if self.options.tree:
            print self.treePath
            sys.exit()

        # if requested, scan the ports tree for problems
        if self.options.lint:
            self._checkSourceTree()
            sys.exit()

        # if there is no argument given, exit
        if not args:
            sysExit('You need to specify a search string.\n'
                    "Invoke '" + sys.argv[0] + " -h' for usage information.")
        else:
            port = args[0]

        # split the argument into a port name and a version
        name, version = self._splitPortSpecIntoNameAndVersion(port)

        # find the port in the HaikuPorts tree
        category = self._getCategory(name)
        if category == None:
            sysExit('Port ' + name + ' not found in tree.')

        baseDir = self.treePath + '/' + category + '/' + name

        # if the port version was not specified, list available versions
        if version == None:
            versions = []
            reRecipeFile = re.compile(regExp['recipefilename'])
            dirList = os.listdir(baseDir)
            for item in dirList:
                m = reRecipeFile.match(item)
                if m:
                    versions.append([m.group('version'), item])
            if len(versions) > 0:
                print 'Following versions of %s are available:' % name
                for version in versions:
                    print '  ' + version[0]
                sysExit('Please run haikuporter again, specifying a port '
                        + 'version')
            else:
                sysExit('No recipe files for %s found.' % name)
    
        # clean the work dir and don't build when making a source archive
        if self.options.archive:
            self.options.package = False
            self.options.build = False
            self.options.clean = True
            self.options.patch = True
    
        # don't build or package when not patching
        if not self.options.patch:
            self.options.build = False
            self.options.package = False

        # update repository if it exists and isn't empty, populate it otherwise
        if (os.path.isdir(self.repositoryPath) 
            and os.listdir(self.repositoryPath)):
            self._updateRepository()
        else:
            self._populateRepository()
            
        # do whatever's needed to the main port
        allPorts = self._getAllPorts();
        self._doMainPort(allPorts[name + '-' + version])

    def _doMainPort(self, port):
        """Build/Unpack/... the port requested on the cmdline"""
            
        # read data from the recipe file
        if not port.revision:
            port.parseRecipeFile()

        # show port description, if requested
        if self.options.about:
            port.printDescription()
            sys.exit()

        # warn when the port is not stable on this architecture
        status = port.getStatusOnCurrentArchitecture();
        if status != Status.STABLE:
            warn('This port is %s on this architecture.' % status)
            if not self.options.yes:
                answer = raw_input('Continue (y/n + enter)? ')
                if answer == '':
                    sys.exit(1)
                if answer[0].lower() == 'y':
                    print ' ok'
                else:
                    sys.exit(1)

        if port.recipeKeys['MESSAGE']:
            print port.recipeKeys['MESSAGE']
            if not self.options.yes:
                answer = raw_input('Continue (y/n + enter)? ')
                if answer == '':
                    sys.exit(1)
                if answer[0].lower() == 'y':
                    print ' ok'
                else:
                    sys.exit(1)

        if self.options.build:
            self._buildMainPort(port)

        # TODO: reactivate these!
        # if self.options.archive:
        #    port.makePatchedArchive()
        # if self.options.test:
        #    port.test()

    def _buildMainPort(self, port):
        """Build the port given on cmdline"""

        packageInfo = self.repositoryPath + '/' + port.packageInfoName
        if not os.path.exists(packageInfo):
            port.writePackageInfoIntoRepository(self.repositoryPath)
        
        # TODO: decide which of these we really want.
        #buildDependencies \
        #    = port.resolveBuildDependencies(self.repositoryPath,
        #                                    self.packagesPath)
        buildDependencies \
            = port.resolveStrictBuildDependencies(self.repositoryPath,
                                                  self.packagesPath)
        allPorts = self._getAllPorts()
        requiredPortsToBuild = []
        for dependency in buildDependencies:
            if dependency.startswith(self.repositoryPath):
                packageInfoFileName = os.path.basename(dependency)
                requiredPortID \
                    = packageInfoFileName[:packageInfoFileName.rindex('.')]
                try:
                    requiredPort = allPorts[requiredPortID]
                    requiredPortsToBuild.append(requiredPort)
                except KeyError:
                    sysExit('Inconsistency: ' + port.versionedName
                             + ' requires ' + requiredPortID 
                             + ' but that does not exist!')

        if requiredPortsToBuild:
            print 'The following required ports will be built first:'
            for requiredPort in requiredPortsToBuild:            
                print('\t' + requiredPort.category + '::' 
                      + requiredPort.versionedName)
            #for requiredPort in requiredPortsToBuild:            
            #    self._buildPort(requiredPort, True)
                
        #self._buildPort(port, False)

    def _buildPort(self, port, parseRecipe):
        """Build a single port"""

        print '-' * 70
        print port.versionedName
        print '-' * 70
        
        # pass-on options to port
        port.forceOverride = options.force
        port.beQuiet = options.quiet
        port.avoidChroot = not options.chroot
        
        if parseRecipe:
            port.parseRecipeFile()

        # clean the work directory, if requested
        if self.options.clean:
            port.cleanWorkDirectory()

        port.downloadSource()
        port.checksumSource()
        port.unpackSource()
        if self.options.patch:
            port.patchSource()
            
        port.build(self.packagesPath, self.options.package)
    

    def _initGlobalShellVariables(self):
        # extract the package info from the system package
        output = check_output('package list /system/packages/haiku.hpkg'
            + ' | grep -E "^[[:space:]]*[[:alpha:]]+:[[:space:]]+"', 
            shell=True)

        # get the haiku version
        match = re.search(r"provides:\s*haiku\s+=\s*(\S+)", output);
        if not match:
            sysExit('Failed to get Haiku version!')
        self.haikuVersion = match.group(1)

        # get the architecture
        match = re.search(r"architecture:\s*(\S+)", output);
        if not match:
            sysExit('Failed to get Haiku architecture!')
        self.architecture = match.group(1)

        self.shellVariables = {
            'haikuVersion': self.haikuVersion,
            'architecture': self.architecture,
            'jobs': str(self.options.jobs),
        }
        if self.options.quiet:
            self.shellVariables['quiet'] = '1'

    def _updatePortsTree(self):
        """Get/Update the port tree via svn"""
        print 'Refreshing the port tree: %s' % self.treePath
        if os.path.exists(self.treePath + '/.svn'):
            check_call(['svn', 'update', self.treePath])
        else:
            check_call(['svn', 'checkout', svnPath, self.treePath])

    def _searchPorts(self, regExp):
        """Search for a port in the HaikuPorts tree"""
        if regExp:
            reSearch = re.compile(regExp)
        os.chdir(self.treePath)
        dirList = os.listdir(self.treePath)
        for category in dirList:
            if os.path.isdir(category) and category[0] != '.':
                subdirList = os.listdir(category)
                # remove items starting with '.'
                subdirList.sort()
                for portName in subdirList:
                    if (portName[0][0] != '.' 
                        and (not regExp or reSearch.search(portName))):
                        print category + '/' + portName

    def _splitPortSpecIntoNameAndVersion(self, portSpec):
        reWithVersion = re.compile(regExp['portfullname'])
        reWithoutVersion = re.compile(regExp['portname'] + '$')
        if reWithVersion.match(portSpec):  # with version
            m = reWithVersion.match(portSpec)
            return m.group('name'), m.group('version')
        elif reWithoutVersion.match(portSpec):
            m = reWithoutVersion.match(portSpec)
            return m.group('name'), None
        else:
            # invalid argument
            sysExit('Invalid port name ' + portSpec)

    def _getCategory(self, portName):
        """Find location of the specified port in the HaikuPorts tree"""
        hierarchy = []
        os.chdir(self.treePath)
        dirList = os.listdir(self.treePath)
        for item in dirList:
            if os.path.isdir(item) and item[0] != '.' and '-' in item:
                subdirList = os.listdir(item)
                # remove items starting with '.'
                subdirList.sort()
                while subdirList[0][0] == '.':
                    del subdirList[0]

                # locate port
                try:
                    if subdirList.index(portName) >= 0:
                        # port was found in the category specified by 'item'
                        return item
                except ValueError:
                    pass
                hierarchy.append([item, subdirList])
        return None

    def _checkSourceTree(self):
        print 'Checking HaikuPorts tree at: ' + self.treePath

        allPorts = self._getAllPorts()
        for portID in sorted(allPorts.keys()):
            port = allPorts[portID]
            print '%s   [%s]' % (portID, port.category)
            try:
                port.validateRecipeFile()
            except SystemExit as e:
                print e.code

    def _populateRepository(self):
        """Remove and refill the repository with all PackageInfo-files from
           parseable recipes"""
           
        if os.path.exists(self.repositoryPath):
            shutil.rmtree(self.repositoryPath)
        tempRepositoryPath = self.repositoryPath + '.new'
        if os.path.exists(tempRepositoryPath):
            shutil.rmtree(tempRepositoryPath)
        os.mkdir(tempRepositoryPath)
        print 'Populating repository ...'

        allPorts = self._getAllPorts()
        for portID in sorted(allPorts.keys()):
            port = allPorts[portID]
            try:
                port.parseRecipeFile()
                status = port.getStatusOnCurrentArchitecture()
                if status == Status.STABLE:
                    print '\t%s' % port.versionedName
                    port.writePackageInfoIntoRepository(tempRepositoryPath)
                    port.unsetFlag('build')
                else:
                    print('\t%s is skipped, as it is %s on this architecture'
                          % (port.versionedName, status))
            except SystemExit:
                pass
        os.rename(tempRepositoryPath, self.repositoryPath)

    def _updateRepository(self):
        """Update all PackageInfo-files in the repository as needed"""
        
        print 'Checking if any recipes have changed ...'
        allPorts = self._getAllPorts()
        packageInfos = glob.glob(self.repositoryPath + '/*.PackageInfo')
        for packageInfo in packageInfos:
            packageInfoFileName = os.path.basename(packageInfo)
            portID = packageInfoFileName[:packageInfoFileName.rindex('.')]
            if portID in allPorts:
                port = allPorts[portID]
                if (not os.path.exists(packageInfo)
                    or (os.path.getmtime(port.recipeFilePath) 
                        > os.path.getmtime(packageInfo))):
                    print '\tupdating ' + packageInfoFileName
                    port.writePackageInfoIntoRepository(self.repositoryPath)
                    port.unsetFlag('build')
            else:
                print '\tremoving ' + packageInfoFileName
                os.remove(packageInfo)

    def _getAllPorts(self):
        if hasattr(self, '_allPorts'):
            return self._allPorts

        self._allPorts = {}
        for category in sorted(os.listdir(self.treePath)):
            categoryPath = self.treePath + '/' + category
            if (not os.path.isdir(categoryPath) or category[0] == '.'
                or '-' not in category):
                continue
            for port in sorted(os.listdir(categoryPath)):
                portPath = categoryPath + '/' + port
                if not os.path.isdir(portPath) or port[0] == '.':
                    continue
                for recipe in os.listdir(portPath):
                    recipePath = portPath + '/' + recipe
                    if (not os.path.isfile(recipePath) 
                        or not recipe.endswith('.recipe')):
                        continue
                    reWithVersion = re.compile(regExp['recipefilename'])
                    m = reWithVersion.match(recipe)
                    if (m and m.group('name') and m.group('version')):
                        name = m.group('name')
                        version = m.group('version')
                        self._allPorts[name + '-' + version] \
                            = Port(name, version, category, portPath, 
                                   self.shellVariables)
                    else:
                        # invalid argument
                        print("Error: Couldn't parse port/version info: " 
                              + recipe)
        return self._allPorts


# -- /etc/haikuports.conf and *.recipe parser --------------------------------

class Config:
    def __init__(self, filename, keysAndTypes, shellVariables={}):
        self.entries = {}

        # set up the shell environment -- we want it to inherit some of our
        # variables
        shellEnv = os.environ
        shellEnv.update(shellVariables)

        # execute the config file via the shell ....
        supportedKeysString = ' '.join(keysAndTypes.keys())
        wrapperScript = configFileEvaluatorScript % (filename, 
                                                     supportedKeysString)
        try:
            output = check_output(['/bin/bash', '-c', wrapperScript], 
                                  env=shellEnv)
        except (OSError, CalledProcessError):
            sysExit("Can't evaluate config file: " + filename)

        # ... and collect the resulting configurations (one per line)
        lines = output.splitlines()
        for line in lines:
            key, separator, valueString = line.partition('=')
            if not separator:
                sysExit('evaluating file %s produced illegal '
                        'key-values line:\n  %s\nexpected "<key>=<value>"\n'
                        'output of configuration script was: %s\n' 
                        % (filename, line, output))
                
            if key not in keysAndTypes:
                # skip unsupported key, just in case
                warn('Key %s in file %s is unsupported, ignoring it'
                     % (key, filename))
                continue
            
            valueString = valueString.replace(r'\n', '\n')
                # replace quoted newlines by real newlines
                
            type = keysAndTypes[key]
            if type == types.StringType:
                self.entries[key] = valueString
            elif type == types.IntType:
                try:
                    self.entries[key] = int(valueString)
                except ValueError:
                    sysExit('evaluating file %s produced illegal value '
                            '"%s" for key %s, expected an <integer> value'
                            % (filename, key, valueString))
            elif type == types.ListType:
                values = [v.strip() for v in valueString.splitlines()]
                self.entries[key] = [v for v in values if len(v) > 0]
            elif type == LinesOfText:
                # like a list, but only strip empty lines in front of and
                # after the text
                values = [v.strip() for v in valueString.splitlines()]
                while values and len(values[0]) == 0:
                    values.pop(0)
                while values and len(values[-1]) == 0:
                    values.pop()
                self.entries[key] = values
            elif type == PhaseType:
                if valueString.upper() not in PhaseType.getAllowedValues():
                    sysExit('evaluating file %s\nproduced illegal value "%s" '
                            'for key %s\nexpected one of: %s'
                            % (filename, key, valueString, 
                               ','.join(PhaseType.getAllowedValues())))
                self.entries[key] = valueString.upper()
            elif type == ArchitecturesType:
                self.entries[key] = {}
                for value in [v.lower() for v in valueString.split()]:
                    architecture = ''
                    if value.startswith('?'):
                        status = Status.UNTESTED
                        architecture = value[1:]
                    elif value.startswith('!'):
                        status = Status.BROKEN
                        architecture = value[1:]
                    else:
                        status = Status.STABLE
                        architecture = value
                    knownArchitectures = ArchitecturesType.getArchitectures()
                    if architecture not in knownArchitectures:
                        architectures = ','.join(knownArchitectures)
                        sysExit('%s refers to unknown architecture %s\n'
                                'known architectures: %s'
                                % (filename, architecture, architectures))
                    self.entries[key][architecture] = status
                if 'any' in self.entries[key] and len(self.entries[key]) > 1:
                    sysExit("%s specifies both 'any' and other architectures" 
                            % (filename))
            else:
                sysExit('type of key %s in file %s is unsupported'
                        % (key, filename))
        # for key in self.entries:
        #    print key + " = " + str(self.entries[key])

    def getEntries(self):
        return self.entries

    def valueOf(self, key):
        try:
            value = self.entries[key]
            return value
        except KeyError:
            # an unspecified entry is the same as an empty one
            return ''


# -- Command line argument parsing -------------------------------------------

parser =  OptionParser(usage='usage: %prog [options] portname[-portversion]',
                       version='%prog ' + info['version'])

parser.add_option('-l', '--list', action='store_true', dest='list',
                  default=False, help='list available ports')
parser.add_option('-a', '--about', action='store_true', dest='about',
                  default=False, help='show description of the specified port')
parser.add_option('-s', '--search', action='store_true', dest='search',
                  default=False, help='search for a port (regex)')
parser.add_option('-n', '--nopatch', action='store_false', dest='patch',
                  default=True, help="don't patch the sources, just download "
                                     "and unpack")
parser.add_option('-b', '--nobuild', action='store_false', dest='build',
                  default=True, help="don't build the port, just download, "
                                     "unpack and patch")
parser.add_option('-p', '--nopackage', action='store_false', dest='package',
                  default=True, help="don't create package, stop after build")
parser.add_option('-C', '--nochroot', action='store_false', dest='chroot',
                  default=True, help="don't use a chroot()-environment")
parser.add_option('-c', '--clean', action='store_true', dest='clean',
                  default=False, help="clean the working directory of the "
                                      "specified port")
parser.add_option('-g', '--get', action='store_true', dest='get',
                  default=False, help="get/update the ports tree")
parser.add_option('-f', '--force', action='store_true', dest='force',
                  default=False, help="force to perform the steps (unpack, "
                                      "patch, build)")
parser.add_option('-q', '--quiet', action='store_true', dest='quiet',
                  default=False, help="suppress output from build actions")
parser.add_option('-z', '--archive', action='store_true', dest='archive',
                  default=False, help="Create a patched source archive as "
                                      "<package>_haiku.tar.xz")
parser.add_option('-t', '--tree', action='store_true', dest='tree',
                  default=False, help="print out the location of the "
                                      "haikuports source tree")
parser.add_option('-y', '--yes', action='store_true', dest='yes',
                  default=False, help="answer yes to all questions")
parser.add_option('-j', '--jobs', action='store', type="int", dest='jobs',
                  default=1, help="the number of concurrent jobs to build with")
parser.add_option('-o','--location', action='store_true', dest='location',
                default=False, help="print out the location of a recipe "
                                    "(via search) (for scripted editing)")
parser.add_option('--test', action='store_true', dest='test',
                  default=False, help="run tests on resulting binaries")
parser.add_option('--lint', action='store_true', dest='lint',
                  default=False, help="scan the ports tree for problems")

(options, args) = parser.parse_args()
haikuporter = HaikuPorter(options, args)
