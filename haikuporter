#!/bin/env python
# -*- coding: utf-8 -*-
# copyright 2007-2011 Brecht Machiels
# copyright 2009-2010 Chris Roberts
# copyright 2009-2011 Scott McCreary
# copyright 2009 Alexander Deynichenko
# copyright 2009 HaikuBot (aka RISC)
# copyright 2010-2011 Jack Laxson (Jrabbit)
# copyright 2011 Ingo Weinhold
# copyright 2013 Oliver Tappe

info = {}
info['version'] = 'r' + '$Rev$'[6:-2]

# -- Modules ------------------------------------------------------------------

import glob
import hashlib
import locale
from optparse import OptionParser
import os
import re
import shutil
from subprocess import check_call, PIPE, Popen, CalledProcessError
import sys
import tarfile
import time
import traceback
import types
import urllib2
import zipfile


# -- Modules preloaded for chroot ---------------------------------------------
# These modules need to be preloaded in order to avoid problems with python
# trying to dynamically load them inside a chroot environment
from encodings import string_escape


# -- HaikuPorts options -------------------------------------------------------

# location of haikuports.conf
haikuportsConf = '/etc/haikuports.conf'

svnPath = 'http://ports.haiku-files.org/svn/haikuports/trunk'

# -----------------------------------------------------------------------------

# Create new type 'ArchitecturesType' for identifying the port's status on each
# of the supported architectures.
# Within the string, support for an architecture can be specified like this:
#  'x86'  -> this port is known to work on the 'x86' architecture
#  '?x86' -> this port has not been built/tested on the 'x86' architecture yet,
#            it is expected to work, but that has not been verified
#  '-x86' -> this port is known to have problems on the 'x86' architecture
# An architecture missing from the status specification indicates that nothing
# is known about the status of the port on this architecture.
class ArchitecturesType(str):
    @staticmethod
    def getArchitectures():
        # TODO: fetch this from PackageKit?
        return [
            'any',
            'x86',
            'x86_gcc2',
        ]


# -----------------------------------------------------------------------------

# Create new type 'PhaseType' for identifying a port phase.
class PhaseType(str):
    @staticmethod
    def getAllowedValues():
        return [ 'BUILD', 'TEST', 'INSTALL' ]


# -----------------------------------------------------------------------------

# allowed types of the /etc/haikuports.conf values
haikuportsConfigTypes = {}
haikuportsConfigTypes['PACKAGER'] = types.StringType
haikuportsConfigTypes['PATCH_OPTIONS'] = types.StringType
haikuportsConfigTypes['TREE_PATH'] = types.StringType

haikuportsConfigDefaults = {}  # [required, default]
haikuportsConfigDefaults['PACKAGER'] = [True, None]
haikuportsConfigDefaults['PATCH_OPTIONS'] = [False, None]
haikuportsConfigDefaults['TREE_PATH'] = [True, None]


# -----------------------------------------------------------------------------

# allowed types of the recipe-file values
recipeTypes = {}
recipeTypes['ARCHITECTURES'] = ArchitecturesType
recipeTypes['BUILD_PACKAGE_ACTIVATION_PHASE'] = PhaseType
recipeTypes['BUILD_PREREQUIRES'] = types.ListType
recipeTypes['BUILD_REQUIRES'] = types.ListType
recipeTypes['CHECKSUM_MD5'] = types.StringType
recipeTypes['CONFLICTS'] = types.ListType
recipeTypes['COPYRIGHT'] = types.ListType
recipeTypes['DESCRIPTION'] = types.ListType
recipeTypes['FRESHENS'] = types.ListType
recipeTypes['HOMEPAGE'] = types.StringType
recipeTypes['LICENSE'] = types.ListType
recipeTypes['MESSAGE'] = types.StringType
recipeTypes['PROVIDES'] = types.ListType
recipeTypes['REPLACES'] = types.ListType
recipeTypes['REQUIRES'] = types.ListType
recipeTypes['REVISION'] = types.IntType
recipeTypes['SOURCE_DIR'] = types.StringType
recipeTypes['SRC_URI'] = types.ListType
recipeTypes['SUMMARY'] = types.StringType
recipeTypes['SUPPLEMENTS'] = types.ListType

recipeDefaults = {}  # [required, default]
recipeDefaults['ARCHITECTURES'] = [True, None]
recipeDefaults['BUILD_PACKAGE_ACTIVATION_PHASE'] = [False, PhaseType('BUILD')]
recipeDefaults['BUILD_PREREQUIRES'] = [False, []]
recipeDefaults['BUILD_REQUIRES'] = [False, []]
recipeDefaults['CHECKSUM_MD5'] = [False, None]
recipeDefaults['CONFLICTS'] = [False, []]
recipeDefaults['COPYRIGHT'] = [False, []]
recipeDefaults['DESCRIPTION'] = [True, None]
recipeDefaults['FRESHENS'] = [False, []]
recipeDefaults['HOMEPAGE'] = [True, None]
recipeDefaults['LICENSE'] = [False, []]
recipeDefaults['MESSAGE'] = [False, None]
recipeDefaults['PROVIDES'] = [True, None]
recipeDefaults['REPLACES'] = [False, []]
recipeDefaults['REQUIRES'] = [False, []]
recipeDefaults['REVISION'] = [True, 1]
recipeDefaults['SOURCE_DIR'] = [False, None]
recipeDefaults['SRC_URI'] = [True, []]
recipeDefaults['SUMMARY'] = [True, None]
recipeDefaults['SUPPLEMENTS'] = [False, []]
recipeDefaults['WORKING'] = [False, True]


# -----------------------------------------------------------------------------

# regex to split recipe filenames into port / version
regExp = {}
regExp['portname'] = '^(?P<name>[\w\-\+]+?)'
regExp['portversion'] = '(?P<version>[\w]*?[\d]+([\w\-\\.\+])*)'
regExp['portfullname'] = regExp['portname'] + '-' + regExp['portversion']
regExp['recipefilename'] = regExp['portfullname'] + '\.recipe$'


# -----------------------------------------------------------------------------

# Shell scriptlet that is used to execute a config file and output all the 
# configuration values (in the form of environment variables) which have been
# set explicitly in the configuration file. The first placeholder is substituted 
# with the configuration file, the second with a space separated list of 
# supported configuration keys.
# Note: this script requires bash, it won't work with any other shells
configFileEvaluatorScript = r'''# wrapper script for evaluating config/recipe

# stop on every error
set -e

# source the configuration file
. %s >/dev/null

# output all environment vars we are interested in and which have been set, 
# quoting any newlines in their values
NL=$'\n'
for key in %s 
do
    if [[ -n ${!key+dummy} ]]
    then
        value=${!key}
        echo "$key=${value//$NL/\\n}"
    fi
done
'''


# -----------------------------------------------------------------------------

# Shell scriptlet that is used to trigger one of the actions defined in a build
# recipe.The first placeholder is substituted with the configuration file, the 
# second one with the action to be invoked.
recipeActionScript = r'''# wrapper scriptlet for running an action

# stop on every error
set -e

# provide defaults for every action
BUILD()
{
    true
}

INSTALL()
{
    true
}

TEST()
{
    true
}

echo $PATH

# source the configuration file
. %s >/dev/null

# invoke the requested action
action='%s'
if [[ $quiet ]]; then
    $action >/dev/null
else
    $action
fi
'''


# -----------------------------------------------------------------------------

# Shell scriptlet that prepares a chroot environment for entering.
# Invoked with $packages filled with the list of packages that should
# be activated (via common/packages) and $recipeFilePath pointing to the
# recipe file.
setupChrootScript = r'''

# stop on every error
set -e

mkdir -p \
    dev \
    boot/system/packages \
    boot/common/cache/tmp \
    boot/common/packages \
    boot/common/settings/etc \

ln -sfn /boot/system system
ln -sfn /boot/system/bin bin
ln -sfn /boot/system/package-links packages
ln -sfn /boot/common/cache/tmp tmp
ln -sfn /boot/common/settings/etc etc
ln -sfn /boot/common/var var

# remove any packages that may be lying around
rm -f boot/common/packages/*.hpkg
rm -f boot/system/packages/*.hpkg

# link all system packages
ln -s /boot/system/packages/*.hpkg boot/system/packages/

# link the list of required common packages
for pkg in $packages; do 
    ln -sfn "$pkg" boot/common/packages/
done

# copy recipe file and (optional) license & package directories into the chroot
cp $recipeFile port.recipe
if [ -d ../licenses ]; then
    cp -r ../licenses .
fi    
if [ -d ../patches ]; then
    cp -r ../patches .
fi    

mount -t bindfs -p "source /dev" dev
mount -t packagefs -p "packages $PWD/boot/system/packages; type system" \
      boot/system
mount -t packagefs -p "packages $PWD/boot/common/packages; type common" \
      boot/common
'''


# -----------------------------------------------------------------------------

# Shell scriptlet that cleans up a chroot environment after it has been exited.
# Invoked with $buildOk indicating if the build has worked and thus all paths 
# required for building only should be wiped.
cleanupChrootScript = r'''

# try to make sure we really are in a work directory
if ! echo $(basename $PWD) | grep -qE '^work-'; then 
    echo "cleanupChroot invoked in $PWD, which doesn't seem to be a work dir!"
    exit 1
fi

unmount boot/system
unmount boot/common
unmount dev

# wipe files and directories if it is ok to do so
if [[ $buildOk ]]; then
    echo "cleaning chroot folder"
    rmdir dev
    rm -rf \
        boot \
        licenses \
        packages \
        licenses \
        system
    rm \
        bin \
        etc \
        port.recipe \
        tmp \
        var
else
    echo "keeping chroot folder $PWD intact for inspection"
fi
'''


# -- global configuration ----------------------------------------------------
haikuportsConfig = {}


# -- capture output of shell command -----------------------------------------
def check_output(*popenargs, **kwargs):
    """local clone of subprocess.check_output() provided by python-2.7
       TODO: drop this once we have upgraded python to 2.7"""
    process = Popen(stdout=PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        raise CalledProcessError(retcode, cmd)
    return output


# -- Set up locale for thousands seperators ----------------------------------
def _ourLocaleconv(lc=locale.localeconv()):
    lc.update({'thousands_sep': ',', 'grouping': [3, 3, 0]})
    return lc

locale.localeconv = _ourLocaleconv


# -- wraps invocation of 'finddir'
def findDirectory(aDir, subDirPath = None):
    result = check_output(['/bin/finddir', aDir]).rstrip()  # drop newline
    if subDirPath != None:
        result += '/' + subDirPath
    return result


# -- Scoped resource for chroot environments ---------------------------------
class ChrootSetup:
    def __init__(self, chrootPath, packagesToBeActivated, recipeFilePath):
        self.path = chrootPath
        self.packages = packagesToBeActivated
        self.recipeFile = recipeFilePath
        self.buildOk = False

    def __enter__(self):
        # execute the chroot setup scriptlet via the shell ...
        os.chdir(self.path)
        shellEnv = { 
            'packages': '\n'.join(self.packages), 
            'recipeFile': self.recipeFile, 
        }
        check_call(['/bin/bash', '-c', setupChrootScript], env=shellEnv)
        return self
    
    def __exit__(self, type, value, traceback):
        # execute the chroot cleanup scriptlet via the shell ...
        os.chdir(self.path)
        shellEnv = {}
        if self.buildOk:
            shellEnv['buildOk'] = '1'
        check_call(['/bin/bash', '-c', cleanupChrootScript], env=shellEnv)


# -- A single port with its recipe, allows to execute actions ----------------
class Port:
    def __init__(self, name, version, category, baseDir, globalShellVariables):
        self.name = name
        self.version = version
        self.versionedName = name + '-' + version
        self.category = category            
        self.baseDir = baseDir
        self.architecture = globalShellVariables['architecture']
        self.shellVariables = globalShellVariables
        self.shellVariables.update({
            'portName': self.name,
            'portVersion': self.version,
            'portVersionedName': self.versionedName,
        })
        
        self.forceOverride = False
        self.beQuiet = False
        self.avoidChroot = False

        self.buildPackage = None
        self.activeBuildPackage = None

        # Each port creates at least one package (which will share its name).
        # If additional packages are declared in the recipe, they will be 
        # added here, later.
        self.packages = [
            {
        		'name': name,
            }
        ]

        # create full paths for the directories
        self.downloadDir = self.baseDir + '/download'
        self.patchesDir = self.baseDir + '/patches'
        self.workDir = self.baseDir + '/work-' + self.version
        self.sourceDir = self.sourceBaseDir = self.workDir + '/sources'
        self.packagingDir = self.workDir + '/packaging'
        
    def __enter__(self):
        return self
    
    def __exit__(self, type, value, traceback):
        pass

    def parseRecipeFile(self):
        """Parse the recipe-file of the specified port"""
        self.validateRecipeFile()

        # set default values when not provided
        for key in recipeDefaults:
            if key not in self.recipeKeys:
                self.recipeKeys[key] = recipeDefaults[key][1]
                
        # If a SOURCE_DIR was specified, adjust the default
        if self.recipeKeys['SOURCE_DIR']:
            self.sourceDir = (self.sourceDir + '/' + 
                              self.recipeKeys['SOURCE_DIR'])

        # initialize variables that depend on the recipe revision
        self.revision = str(self.recipeKeys['REVISION'])
        self.fullVersion = self.version + '-' + self.revision
        self.revisionedName = self.name + '-' + self.fullVersion
        self.packages[0]['filename'] \
            = self.revisionedName + '-' + self.architecture + '.hpkg'
        self.packages[0]['fullPath'] \
            = self.workDir + '/' + self.packages[0]['filename']

        # set up the complete list of variables we'll inherit to the shell
        # when executing a recipe action
        self._initShellVariablesFromRecipe()

        # for key in self.recipeKeys:
        #     print key + " = " + str(self.recipeKeys[key])

    def validateRecipeFile(self):
        """Validate the syntax and contents of the recipe file"""
        
        recipeFilePath = (self.baseDir + '/' + self.name + '-' + self.version 
                          + '.recipe')
        if not os.path.exists(recipeFilePath):
            sys.exit('Error: ' + self.name + ' version ' + self.version 
                     + ' not found.')

        recipeConfig = Config(recipeFilePath, recipeTypes, self.shellVariables)
        self.recipeFilePath = recipeFilePath
        self.recipeKeys = recipeConfig.getEntries()

        # check whether all required fields are present
        for key in recipeDefaults:
            if key not in self.recipeKeys and recipeDefaults[key][0]:
                sys.exit("Error: Required field '" + key\
                         + "' not present in " + recipeFilePath)

        # Check for a valid license file
        if 'LICENSE' in self.recipeKeys:
            fileList = []
            recipeLicense = self.recipeKeys['LICENSE']
            for item in recipeLicense:
                dirname = findDirectory('B_SYSTEM_DIRECTORY', 'data/licenses')
                haikuLicenseList = fileList = os.listdir(dirname)
                if item not in fileList:
                    fileList = []
                    dirname = os.path.dirname(recipeFilePath) + '/licenses'
                    if os.path.exists(dirname):
                        for filename in os.listdir(dirname):
                            fileList.append(filename)
                if item not in fileList:
                    haikuLicenseList.sort()
                    sys.exit(('\n######## Error: No match found for License %s '
                              '########\n' % item) + '\n'
                              + 'Valid license filenames included with Haiku '
                              + 'are:\n\n' + '\n'.join(haikuLicenseList) + '\n')

        if 'LICENSE' not in self.recipeKeys or not self.recipeKeys['LICENSE']:
            print 'Warning: No LICENSE found in recipe file'

        if ('COPYRIGHT' not in self.recipeKeys 
            or not self.recipeKeys['COPYRIGHT']):
            print 'Warning: No COPYRIGHT found in recipe file'

    def printDescription(self):
        """Show port description"""
        print '*' * 80
        if 'SUMMARY' in self.recipeKeys:
            print 'SUMMARY: %s' % self.recipeKeys['SUMMARY']
        if 'SUMMARY' in self.recipeKeys:
            print 'DESCRIPTION: %s' % self.recipeKeys['DESCRIPTION']
        if 'HOMEPAGE' in self.recipeKeys:
            print 'HOMEPAGE: %s' % self.recipeKeys['HOMEPAGE']
        print '*' * 80

    def getStatusOnCurrentArchitecture(self):
        """Return the status of this port on the current architecture"""
        if self.architecture in self.recipeKeys['ARCHITECTURES']:
            return self.recipeKeys['ARCHITECTURES'][self.architecture]
        return 'unsupported'
    
    def generatePackageInfo(self, path):
        """Create a corresponding .PackageInfo"""
        
        packageInfoFile = path + '/' + self.revisionedName + '.PackageInfo'
        self._generatePackageInfo(packageInfoFile, False, True)
        
    def cleanWorkDirectory(self):
        """Clean the working directory"""
        if os.path.exists(self.workDir):
            print 'Cleaning work directory...'
            shutil.rmtree(self.workDir)
                
    def downloadSource(self):
        """Fetch the source archive"""
        for src_uri in self.recipeKeys['SRC_URI']:
            # Examine the URI to determine if we need to perform a checkout
            # instead of download
            if re.match('^cvs.*$|^svn.*$|^hg.*$|^git.*$|^bzr.*$|^fossil.*$',
                        src_uri):
                self.checkoutSource(src_uri)
                return

            try:
                # Need to make a request to get the actual uri in case it is an
                # http redirect
                uri_request = urllib2.urlopen(src_uri)
                src_uri = uri_request.geturl()

                self.src_local = src_uri[src_uri.rindex('/') + 1:]
                fp = self.downloadDir + '/' + self.src_local
                if os.path.isfile(fp):
                    print 'Skipping download ...'
                    return
                else:
                    # create download dir and cd into it
                    if not os.path.exists(self.downloadDir):
                        os.mkdir(self.downloadDir)

                    os.chdir(self.downloadDir)

                    print '\nDownloading: ' + src_uri
                    check_call(['wget', '-c', '--tries=3', src_uri])

                    # succesfully downloaded source archive
                    return
            except Exception:
                print 'Warning: download error, trying next location.'

        # failed to fetch source
        sys.exit('Error: Failed to download source package from all locations.')

    def checkoutSource(self, uri):
        """Parse the URI and execute the appropriate command to check out the
           source.
        """
        if self._checkFlag('checkout') and not self.forceOverride:
            print 'Source already checked out. Skipping ...'
            return

        # If the work dir exists we need to clean it out
        if os.path.exists(self.workDir):
            shutil.rmtree(self.workDir)

        print 'Source checkout: ' + uri

        # Attempt to parse a URI with a + in it. ex: hg+http://blah
        # If it doesn't find the 'type' it should extract 'real_uri' and 'rev'
        m = re.match('^((?P<type>\w*)\+)?(?P<real_uri>.+?)(#(?P<rev>.+))?$',
                     uri)
        if not m or not m.group('real_uri'):
            sys.exit("Error: Couldn't parse repository URI")

        type = m.group('type')
        real_uri = m.group('real_uri')
        rev = m.group('rev')

        # Attempt to parse a URI without a + in it. ex: svn://blah
        # TODO improve the regex above to fallback to this pattern
        if not type:
            m = re.match("^(\w*).*$", real_uri)
            if m:
                type = m.group(1)

        if not type:
            sys.exit("Error: Couldn't determine repository type")

        # Set the name of the directory to check out sources into
        checkoutDir = self.name + '-' + self.version

        # Start building the command to perform the checkout
        if type == 'cvs':
            # Chop off the leading cvs:// part of the uri
            real_uri = real_uri[real_uri.index('cvs://') + 6:]

            # Extract the cvs module from the uri and remove it from real_uri
            module = real_uri[real_uri.rfind('/') + 1:]
            real_uri = real_uri[:real_uri.rfind('/')]
            checkoutCommand = 'cvs -d' + real_uri + ' co -P'
            if rev:
                # For CVS 'rev' specifies a date
                checkoutCommand += ' -D' + rev
            checkoutCommand += ' -d ' + checkoutDir + ' ' + module
        elif type == 'svn':
            checkoutCommand \
                = 'svn co --non-interactive --trust-server-cert'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'hg':
            checkoutCommand = 'hg clone'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'bzr':
            # http://doc.bazaar.canonical.com/bzr-0.10/bzr_man.htm#bzr-branch-from-location-to-location
            checkoutCommand = 'bzr checkout --lightweight'
            if rev:
                checkoutCommand += ' -r ' + rev
            checkoutCommand += ' ' + real_uri + ' ' + checkoutDir
        elif type == 'fossil':
            # http://fossil-scm.org/index.html/doc/trunk/www/quickstart.wiki
            if os.path.exists(checkoutDir + '.fossil'):
                shutil.rmtree(checkoutDir + '.fossil')
            checkoutCommand = 'fossil clone ' + real_uri
            checkoutCommand += ' ' + checkoutDir + '.fossil'
            checkoutCommand += ' && '
            checkoutCommand += 'mkdir -p ' + checkoutDir
            checkoutCommand += ' && '
            checkoutCommand += 'fossil open ' + checkoutDir + '.fossil'
            if rev:
                checkoutCommand += ' ' + rev
        else:
            # TODO Skip the initial checkout if a rev is specified?
            checkoutCommand = 'git clone %s %s' % (real_uri, checkoutDir)
            if rev:
                checkoutCommand += (' && cd %s'
                                    ' && git checkout %s' % (checkoutDir, rev))

        # create the source-base dir
        if not os.path.exists(self.sourceBaseDir):
            os.makedirs(self.sourceBaseDir)

        check_call(checkoutCommand, shell=True, cwd=self.sourceBaseDir)

        # Set the 'checkout' flag to signal that the checkout is complete
        # This also tells haikuporter not to attempt an unpack step
        self._setFlag('checkout')

    def checksumSource(self):
        if self.recipeKeys['CHECKSUM_MD5']:
            sys.stdout.write('Calculating checksum -')
            sys.stdout.flush()
            h = hashlib.md5()
            f = open(self.downloadDir + '/' + self.src_local, 'rb')
            while True:
                d = f.read(16384)
                if not d:
                    break
                h.update(d)
            f.close()
            if h.hexdigest() == self.recipeKeys['CHECKSUM_MD5']:
                sys.stdout.write(' OK\n')
            else:
                sys.exit(' FAILED\nExpected: ' + self.recipeKeys['CHECKSUM_MD5'] 
                         +  '\nFound: ' + h.hexdigest() + '\n')
            sys.stdout.flush()
        else:
            # The checkout flag only gets set when a source checkout is 
            # performed. If it exists we don't need to warn about the missing 
            # recipe field
            if not self._checkFlag('checkout'):
                print 'Warning: CHECKSUM_MD5 key not found in recipe file.'

    def unpackSource(self):
        """Unpack the source archive (into the work directory)"""

        # If the source came from a vcs there is no unpack step
        if self._checkFlag('checkout'):
            return

        # create source-base dir
        if not os.path.exists(self.sourceBaseDir):
            os.makedirs(self.sourceBaseDir)

        # Check to see if the source archive was already unpacked.
        if self._checkFlag('unpack') and not self.forceOverride:
            print 'Skipping unpack ...'
            return

        # unpack source archive
        print 'Unpacking ' + self.src_local
        archiveFullPath = self.downloadDir + '/' + self.src_local
        if tarfile.is_tarfile(archiveFullPath):
            tf = tarfile.open(self.downloadDir + '/' + self.src_local, 'r')
            tf.extractall(self.sourceBaseDir)
            tf.close()
        elif zipfile.is_zipfile(archiveFullPath):
            zf = zipfile.ZipFile(self.downloadDir + '/' + self.src_local, 'r')
            zf.extractall(self.sourceBaseDir)
            zf.close()
        elif archiveFullPath.split('/')[-1].split('.')[-1] == 'xz':
            Popen(['xz', '-d', '-k', archiveFullPath]).wait()
            tar = archiveFullPath[:-3]
            if tarfile.is_tarfile(tar):
                tf = tarfile.open(tar, 'r')
                tf.extractall(self.sourceBaseDir)
                tf.close()
        else:
            sys.exit('Error: Unrecognized archive type.')

        self._setFlag('unpack')

    def patchSource(self):
        """Apply the Haiku patches to the source directory"""
        # Check to see if the patch was already applied to the source.
        if self._checkFlag('patch') and not self.forceOverride:
            return

        patchFilePath = self.patchesDir + '/' + self.name + '-'\
             + self.version + '.patch'
        if os.path.exists(patchFilePath):
            print 'Patching ...'
            patchOptions = ''
            if 'PATCH_OPTIONS' in haikuportsConfig:
                patchOptions += haikuportsConfig['PATCH_OPTIONS']
            check_call('patch -p0 ' + patchOptions + ' -i '
                        + patchFilePath, shell=True, cwd=self.sourceBaseDir)
        else:
            print 'No patching required'
        self._setFlag('patch')

    def build(self, makePackage):
        """Build the port"""
        requiredPackages = [
            '/boot/common/packages/autoconf-2.68-2-x86_gcc2.hpkg',
            '/boot/common/packages/automake-1.11.1-2-x86_gcc2.hpkg',
            '/boot/common/packages/gcc-2.95.3_110711-2-x86_gcc2.hpkg',
            '/boot/common/packages/libiconv-1.13.1-2-x86_gcc2.hpkg',
            '/boot/common/packages/libtool-2.4-2-x86_gcc2.hpkg',
            '/boot/common/packages/libxml2-2.7.8-2-x86_gcc2.hpkg',
            '/boot/common/packages/m4-1.4.16-2-x86_gcc2.hpkg',
            '/boot/common/packages/make-3.82-2-x86_gcc2.hpkg',
            '/boot/common/packages/openssl-1.0.0d-2-x86_gcc2.hpkg',
            '/boot/common/packages/perl-5.10.1-2-x86_gcc2.hpkg',
            '/boot/common/packages/sed-4.2.1-1-x86_gcc2.hpkg',
            '/boot/common/packages/tar-1.25-1-x86_gcc2.hpkg',
        ]    # TODO: get these from pkgman!

        if self.avoidChroot:
            self._executeBuild(makePackage)
        else:
            # setup chroot and keep it while executing the actions
            with ChrootSetup(self.workDir, requiredPackages, 
                             self.recipeFilePath) as chrootSetup:
                pid = os.fork()
                if pid == 0:
                    # child, enter chroot and execute the build
                    try:
                        os.chroot(self.workDir)
                        self._adjustToChroot()
                        self._executeBuild(makePackage)
                    except:
                        traceback.print_exc()
                        os._exit(1)
                    os._exit(0)

                # parent, wait on child
                if os.waitpid(pid, 0)[1] == 0:
                    chrootSetup.buildOk = True

        if makePackage:                    
            # move all created packages into repository
            packagesDir = self.baseDir + '/../../packages/'
            for package in self.packages:
                if os.path.exists(package['fullPath']):
                    print 'grabbing ' + package['filename']
                    os.rename(package['fullPath'], 
                              packagesDir + package['filename'])

    def test(self, makePackage):
        """Test the port"""
        
        # TODO!

    def makePatchedArchive(self):
        """Create a patched source archive"""
        print 'Creating patched source archive ...'

        # Set the path and filename for the archive.
        date = time.strftime('-%Y-%m-%d', time.localtime())
        archiveFile = self.baseDir + '/' + self.name + '-'\
             + self.version + '_haiku' + date + '.tar.xz'

        sourceFiles = ''

        # Build the list of dirs to archive.
        # Since we don't know the name we have to iterate over the dir.
        for f in os.listdir(self.sourceBaseDir):
            if os.path.isdir(self.sourceBaseDir + '/' + f):
                sourceFiles += ' ' + f

        # Make sure we found something to archive
        if not sourceFiles:
            sys.exit('Error: No source directories found in work dir.')

        # Archive the package and save it in the root of the port dir.
        check_call('tar cJvf ' + archiveFile + ' ' + sourceFiles,
                   shell=True, cwd=self.sourceBaseDir)

        # Clean up after ourselves
        shutil.rmtree(self.workDir)

        print 'Archive saved to: ' + archiveFile

    def _initShellVariablesFromRecipe(self):
        """Fill dictionary with variables that will be inherited to the shell
           when executing recipe actions
        """
        prefix = findDirectory('B_PACKAGE_LINKS_DIRECTORY',
            self.revisionedName + '/.self')

        self.shellVariables.update({
            'portRevision': self.revision,
            'portFullVersion': self.fullVersion,
            'portRevisionedName': self.revisionedName,
            'sourceDir': self.sourceDir,
        })

        configureDirs = {
            'prefix': prefix,
            'dataRootDir': prefix + '/data',
            'binDir': prefix + '/bin',
            'sbinDir': prefix + '/bin',
            'libDir': prefix + '/lib',
            'includeDir': prefix + '/develop/headers',
            'sysconfDir': prefix + '/settings',
            'docDir': prefix + '/documentation/packages/' + self.name,
            'infoDir': prefix + '/documentation/info',
            'manDir': prefix + '/documentation/man',
        }
        self.shellVariables.update(configureDirs)

        # add one more variable containing all the dir args for configure:
        self.shellVariables['configureDirArgs'] \
            = ' '.join(['--%s=%s' % (k.lower(), v) 
                       for k, v in configureDirs.iteritems()])

    def _executeBuild(self, makePackage):
        """Executes the build stage and creates all declared packages"""
        self._createBuildPackage()
        self._doBuildStage()
        if makePackage:
            for package in self.packages:
                self._makePackage(package)
        if self.activeBuildPackage and os.path.exists(self.activeBuildPackage):
            os.remove(self.activeBuildPackage)
        if self.buildPackage and os.path.exists(self.buildPackage):
            os.remove(self.buildPackage)

    def _adjustToChroot(self):
        """Adjust directories to chroot()-ed environment"""
        
        # unset directories which can't be reached from inside the chroot
        self.baseDir = None
        self.downloadDir = None
        
        # the recipe file has a fixed same name in the chroot
        self.recipeFilePath = '/port.recipe'

        # adjust all relevant directories
        pathLengthToCut = len(self.workDir)
        self.sourceDir = self.sourceDir[pathLengthToCut:]
        self.sourceBaseDir = self.sourceBaseDir[pathLengthToCut:]
        self.packagingDir = self.packagingDir[pathLengthToCut:]
        self.workDir = ''
        self.patchesDir = '/patches'

        # adjust all package file paths
        for package in self.packages:
            package['fullPath'] = package['fullPath'][pathLengthToCut:]
                
    def _doBuildStage(self):
        """Run the actual build"""
        # activate build package if required at this stage
        if self.recipeKeys['BUILD_PACKAGE_ACTIVATION_PHASE'] == 'BUILD':
            self._activateBuildPackage()
            
        # Check to see if a previous build was already done.
        if self._checkFlag('build') and not self.forceOverride:
            print 'Skipping build ...'
            return

        # Delete and re-create the packaging dir -- the port's build may need
        # to use it.
        if os.path.exists(self.packagingDir):
            shutil.rmtree(self.packagingDir, True)
        os.mkdir(self.packagingDir)

        print 'Building ...'
        self._doRecipeAction('BUILD', self.sourceDir)
        self._setFlag('build')

    def _makePackage(self, package):
        """Create a package suitable for distribution"""
        print 'Creating distribution package ' + package['name'] + ' ...'

        # recreate empty packaging directory
        shutil.rmtree(self.packagingDir, True)
        os.mkdir(self.packagingDir)

        if os.path.exists('/licenses'):
            shutil.copytree('/licenses', self.packagingDir + '/data/licenses')

        self._doInstallStage()
        
        self._generatePackageInfo(self.packagingDir + '/.PackageInfo', False,
                                  self.beQuiet)

        if os.path.exists(package['fullPath']):
            os.remove(package['fullPath'])
        
        # Create the package
        print 'creating package ' + package['filename'] + ' ...'
        os.chdir(self.packagingDir)
        check_call(['package', 'create', package['fullPath']])

        # Clean up after ourselves
        shutil.rmtree(self.packagingDir)

        # give hint about source package for ports using (L)GPL license
        if 'GNU GPL' in self.recipeKeys['LICENSE'] \
            or 'GNU LGPL' in self.recipeKeys['LICENSE']:
            print ('To generate the matching source package, run: '
                   'haikuporter -z ' + self.name + '-' + self.version)

    def _doInstallStage(self):
        """Install the files resulting from the build into the packaging 
           folder"""
        # activate build package if required at this stage
        if self.recipeKeys['BUILD_PACKAGE_ACTIVATION_PHASE'] == 'INSTALL':
            self._activateBuildPackage()
            
        print 'Collecting files to be packaged ...'
        self._doRecipeAction('INSTALL', self.sourceDir)

    def _doTestStage(self):
        """Test the build results"""
        print 'Testing ...'
        self._doRecipeAction('TEST', self.sourceDir)

    def _doRecipeAction(self, action, dir):
        """Run the specified action, as defined in the recipe file"""
        # set up the shell environment -- we want it to inherit some of our
        # variables
        shellEnv = os.environ
        shellEnv.update(self.shellVariables)

        # execute the requested action via a shell ....
        wrapperScript = recipeActionScript % (self.recipeFilePath, action)
        check_call(['/bin/bash', '-c', wrapperScript], cwd=dir, env=shellEnv)

    def _setFlag(self, name):
        open('%s/flag.%s' % (self.workDir, name), 'w').close()

    def _checkFlag(self, name):
        return os.path.exists('%s/flag.%s' % (self.workDir, name))

    def _createBuildPackage(self):
        """Create and activate the build package"""
        # create a package info for a build package
        buildPackageInfo \
            = self.workDir + '/' + self.revisionedName + '-build-package-info'
        self._generatePackageInfo(buildPackageInfo, True, self.beQuiet)

        # create the build package
        buildPackage \
            = self.workDir + '/' + self.revisionedName + '-build.hpkg'
        cmdlineArgs = ['package', 'create', '-bi', buildPackageInfo, '-I',
                       self.packagingDir, buildPackage]
        if self.beQuiet:
            cmdlineArgs.insert(2, '-q')
        check_call(cmdlineArgs)
        self.buildPackage = buildPackage
        os.remove(buildPackageInfo)

    def _activateBuildPackage(self):
        """Activate the build package"""
        # activate the build package
        packagesDir = findDirectory('B_COMMON_PACKAGES_DIRECTORY')
        activeBuildPackage \
            = packagesDir + '/' + os.path.basename(self.buildPackage)
        if os.path.exists(activeBuildPackage):
            os.remove(activeBuildPackage)
            
        if self.avoidChroot:
            # may have to cross devices, so better use a symlink
            os.symlink(self.buildPackage, activeBuildPackage)
        else:
            # symlinking a package won't work in chroot, but in this
            # case we are sure that the move won't cross devices
            os.rename(self.buildPackage, activeBuildPackage)
        self.activeBuildPackage = activeBuildPackage

    def _generatePackageInfo(self, packageInfoPath, isBuildPackage, quiet):
        """Create a .PackageInfo file for inclusion in a package"""
        with open(packageInfoPath, 'w') as infoFile:
            infoFile.write('name\t\t\t' + self.name + '\n')
            infoFile.write('version\t\t\t' + self.fullVersion + '\n')
            infoFile.write('architecture\t\t' + self.architecture + '\n')
            infoFile.write('summary\t\t\t"' + self.recipeKeys['SUMMARY'] 
                           + '"\n')
    
            infoFile.write('description\t\t"')
            infoFile.write('\n'.join(self.recipeKeys['DESCRIPTION']))
            infoFile.write('"\n')
    
            infoFile.write('packager\t\t"' + haikuportsConfig['PACKAGER'] 
                           + '"\n')
            infoFile.write('vendor\t\t\t"Haiku Project"\n')
    
            # These keys aren't mandatory so we need to check if they exist
            if self.recipeKeys['LICENSE']:
                infoFile.write('licenses {\n')
                for license in self.recipeKeys['LICENSE']:
                    infoFile.write('\t"' + license + '"\n')
                infoFile.write('}\n')
    
            if self.recipeKeys['COPYRIGHT']:
                infoFile.write('copyrights {\n')
                for copyright in self.recipeKeys['COPYRIGHT']:
                    infoFile.write('\t"' + copyright + '"\n')
                infoFile.write('}\n')
    
            if isBuildPackage:
                dependencies = self.recipeKeys['REQUIRES'] \
                    + self.recipeKeys['BUILD_REQUIRES'] \
                    + self.recipeKeys['BUILD_PREREQUIRES']
            else:
                dependencies = self.recipeKeys['REQUIRES']
    
            self._writePackageInfoListByKey(infoFile, 'PROVIDES', 'provides')
            self._writePackageInfoList(infoFile, dependencies, 'requires')
            self._writePackageInfoListByKey(infoFile, 'SUPPLEMENTS', 
                                            'supplements')
            self._writePackageInfoListByKey(infoFile, 'CONFLICTS', 'conflicts')
            self._writePackageInfoListByKey(infoFile, 'FRESHENS', 'freshens')
            self._writePackageInfoListByKey(infoFile, 'REPLACES', 'replaces')
    
            infoFile.write('urls\t\t\t"' + self.recipeKeys['HOMEPAGE'] + '"\n')
    
            # Generate SourceURL lines for all ports, regardless of license.
            # Re-use the download URLs, as specified in the recipe.
            infoFile.write('source-urls {\n')
            uricount = 1
            for src_uri in self.recipeKeys['SRC_URI']:
                if uricount < 2:
                    infoFile.write('\t"Download <' + src_uri + '>"\n')
                else:
                    infoFile.write('\t"Location ' + str(uricount) + ' <' 
                                   + src_uri + '>"\n')
                uricount += 1
    
            # Point directly to the file in subversion.
            recipeurl_base = ('http://ports.haiku-files.org/'
                              + 'svn/haikuports/trunk/' + self.category + '/' 
                              + self.name)
    
            recipeurl = (recipeurl_base + '/' + self.name+ '-' + self.version 
                         + '.recipe')
    
            infoFile.write('\t"Port-file <' + recipeurl + '>"\n')
            patchFilePath = (self.patchesDir + '/' + self.name + '-' 
                             + self.version + '.patch')
            if os.path.exists(patchFilePath):
                patchurl = (recipeurl_base + '/patches/' + self.name + '-'
                            + self.version + '.patch')
                infoFile.write('\t"Patches <' + patchurl + '>"\n')
    
            infoFile.write('}\n')
        
        if not isBuildPackage and not quiet:
            with open(packageInfoPath, 'r') as infoFile:
                infoFileDisplay = infoFile.read()
                print infoFileDisplay

    def _writePackageInfoListByKey(self, infoFile, key, keyword):
        self._writePackageInfoList(infoFile, self.recipeKeys[key], keyword)

    def _writePackageInfoList(self, infoFile, list, keyword):
        if list:
            infoFile.write(keyword + ' {\n')
            for item in list:
                infoFile.write('\t' + item + '\n')
            infoFile.write('}\n')


# -- Main Class --------------------------------------------------------------
class HaikuPorter:
    def __init__(self, options, args):
        self.options = options
        
        # read global settings
        global haikuportsConfig
        haikuportsConfig = Config(haikuportsConf, 
                                  haikuportsConfigTypes).getEntries()

        # check whether all required fields are present
        for key in haikuportsConfigDefaults:
            if (key not in haikuportsConfig 
                    and haikuportsConfigDefaults[key][0]):
                sys.exit("Error: Required field '" + key + "' not present in " 
                         + haikuportsConf)

        # set up the global variables we'll inherit to the shell
        self._initGlobalShellVariables()
    
        self.treePath = haikuportsConfig['TREE_PATH'].rstrip('/')
        
        # create path where built packages will be collected
        self.packagesPath = self.treePath + '/packages'
        if not os.path.exists(self.packagesPath):
            os.mkdir(self.packagesPath)

        # the path where repository will be built
        self.repositoryPath = self.treePath + '/repository'

        # if requested, list all ports in the HaikuPorts tree
        if self.options.list:
            self._searchPorts(None)
            sys.exit()

        # if requested, search for a port
        if self.options.search:
            if not args:
                sys.exit('You need to specify a search string.\n'
                         "Invoke '" + sys.argv[0] + " -h' for usage "
                         "information.")
            self._searchPorts(args[0])
            sys.exit()
        
        if self.options.location:
            if not args:
                sys.exit('You need to specify a search string.\n'
                         "Invoke '" + sys.argv[0] + " -h' for usage "
                         "information.")
            # Provide the installed location of a port (for quick editing)
            print os.path.join(self.treePath, self.searchPorts(args[0]))
            sys.exit()

        # if requested, checkout or update ports tree
        if self.options.get:
            self._updatePortsTree()
            sys.exit()

        # if requested, print the location of the haikuports source tree
        if self.options.tree:
            print self.treePath
            sys.exit()

        # if requested, scan the ports tree for problems
        if self.options.lint:
            self._checkSourceTree()
            sys.exit()

        # if there is no argument given, exit
        if not args:
            sys.exit('You need to specify a search string.\n'
                     "Invoke '" + sys.argv[0] + " -h' for usage information.")
        else:
            port = args[0]

        # split the argument into a port name and a version
        name, version = self._splitPortSpecIntoNameAndVersion(port)

        # find the port in the HaikuPorts tree
        category = self._getCategory(name)
        if category == None:
            sys.exit('Error: Port ' + name + ' not found in tree.')

        baseDir = self.treePath + '/' + category + '/' + name

        # if the port version was not specified, list available versions
        if version == None:
            versions = []
            reRecipeFile = re.compile(regExp['recipefilename'])
            dirList = os.listdir(baseDir)
            for item in dirList:
                m = reRecipeFile.match(item)
                if m:
                    versions.append([m.group('version'), item])
            if len(versions) > 0:
                print 'Following versions of %s are available:' % name
                for version in versions:
                    print '  ' + version[0]
                sys.exit('Run haikuporter again, specifying a port version')
            else:
                sys.exit('Error: no recipe files for %s found.' % name)
    
        # populate repository unless already done
        if not os.path.exists(self.repositoryPath + '/.populated'):
            self._populateRepository()

        with Port(name, version, category, baseDir, 
                  self.shellVariables) as port:
            # pass on options if needed
            if self.options.force:
                port.forceOverride = True
            if self.options.quiet:
                port.beQuiet = True
            if not self.options.chroot:
                port.avoidChroot = True

            # read data from the port file
            port.parseRecipeFile()
    
            # show port description, if requested
            if self.options.about:
                port.printDescription()
                sys.exit()
    
            # warn when the port is not stable on this architecture
            status = port.getStatusOnCurrentArchitecture();
            if status != 'stable':
                print 'Warning: This port is %s on this architecture.' % status
                if not self.options.yes:
                    answer = raw_input('Continue (y/n + enter)? ')
                    if answer == '':
                        sys.exit(1)
                    if answer[0].lower() == 'y':
                        print ' ok'
                    else:
                        sys.exit(1)
    
            if port.recipeKeys['MESSAGE']:
                print port.recipeKeys['MESSAGE']
                if not self.options.yes:
                    answer = raw_input('Continue (y/n + enter)? ')
                    if answer == '':
                        sys.exit(1)
                    if answer[0].lower() == 'y':
                        print ' ok'
                    else:
                        sys.exit(1)
    
            # clean the work dir and don't build when making a source archive
            if self.options.archive:
                self.options.package = False
                self.options.build = False
                self.options.clean = True
                self.options.patch = True
    
            # clean the work directory, if requested
            if self.options.clean:
                port.cleanWorkDirectory()
    
            # don't build or package when not patching
            if not self.options.patch:
                self.options.build = False
                self.options.package = False
    
            port.downloadSource()
            port.checksumSource()
            port.unpackSource()
            if self.options.patch:
                port.patchSource()
            if self.options.build:
                port.build(self.options.package)
            # TODO: reactivate these!
            # if self.options.archive:
            #    port.makePatchedArchive()
            # if self.options.test:
            #    port.test()

    def _initGlobalShellVariables(self):
        # extract the package info from the system package
        output = check_output('package list /system/packages/haiku.hpkg'
            + ' | grep -E "^[[:space:]]*[[:alpha:]]+:[[:space:]]+"', 
            shell=True)

        # get the haiku version
        match = re.search(r"provides:\s*haiku\s+=\s*(\S+)", output);
        if not match:
            sys.exit('Failed to get Haiku version!')
        self.haikuVersion = match.group(1)

        # get the architecture
        match = re.search(r"architecture:\s*(\S+)", output);
        if not match:
            sys.exit('Failed to get Haiku architecture!')
        self.architecture = match.group(1)

        self.shellVariables = {
            'haikuVersion': self.haikuVersion,
            'architecture': self.architecture,
            'jobs': str(self.options.jobs),
        }
        if self.options.quiet:
            self.shellVariables['quiet'] = '1'

    def _updatePortsTree(self):
        """Get/Update the port tree via svn"""
        print 'Refreshing the port tree: %s' % self.treePath
        if os.path.exists(self.treePath + '/.svn'):
            check_call(['svn', 'update', self.treePath])
        else:
            check_call(['svn', 'checkout', svnPath, self.treePath])

    def _searchPorts(self, regExp):
        """Search for a port in the HaikuPorts tree"""
        if regExp:
            reSearch = re.compile(regExp)
        os.chdir(self.treePath)
        dirList = os.listdir(self.treePath)
        for category in dirList:
            if os.path.isdir(category) and category[0] != '.':
                subdirList = os.listdir(category)
                # remove items starting with '.'
                subdirList.sort()
                for portName in subdirList:
                    if (portName[0][0] != '.' 
                        and (not regExp or reSearch.search(portName))):
                        print category + '/' + portName

    def _splitPortSpecIntoNameAndVersion(self, portSpec):
        reWithVersion = re.compile(regExp['portfullname'])
        reWithoutVersion = re.compile(regExp['portname'] + '$')
        if reWithVersion.match(portSpec):  # with version
            m = reWithVersion.match(portSpec)
            return m.group('name'), m.group('version')
        elif reWithoutVersion.match(portSpec):
            m = reWithoutVersion.match(portSpec)
            return m.group('name'), None
        else:
            # invalid argument
            sys.exit('Error: Invalid port name ' + portSpec)

    def _getCategory(self, portName):
        """Find location of the specified port in the HaikuPorts tree"""
        hierarchy = []
        os.chdir(self.treePath)
        dirList = os.listdir(self.treePath)
        for item in dirList:
            if os.path.isdir(item) and item[0] != '.' and '-' in item:
                subdirList = os.listdir(item)
                # remove items starting with '.'
                subdirList.sort()
                while subdirList[0][0] == '.':
                    del subdirList[0]

                # locate port
                try:
                    if subdirList.index(portName) >= 0:
                        # port was found in the category specified by 'item'
                        return item
                except ValueError:
                    pass
                hierarchy.append([item, subdirList])
        return None

    def _checkSourceTree(self):
        print 'Checking HaikuPorts tree at: ' + self.treePath

        for (recipePath, port) in self._allPorts().iteritems():
            print '%s::%s-%s' % (port.category, port.version, port.name)
            try:
                port.validateRecipeFile()
            except SystemExit as e:
                print e.code

    def _populateRepository(self):
        if os.path.exists(self.repositoryPath):
            shutil.rmtree(self.repositoryPath)
        os.mkdir(self.repositoryPath)
        print 'Populating repository ...'

        currentCategory = ''
        validatedPorts = []
        allPorts = self._allPorts()
        for recipePath in sorted(allPorts.keys()):
            port = allPorts[recipePath]
            if currentCategory != port.category:
                print port.category
                currentCategory = port.category
            try:
                port.parseRecipeFile()
                validatedPorts.append(port)
                print '\t%s' % port.versionedName
                port.generatePackageInfo(self.repositoryPath)
            except SystemExit:
                pass
        open(self.repositoryPath + '/.populated', 'w').close()

    def _allPorts(self):
        if hasattr(self, 'allPorts'):
            return self.allPorts

        self.allPorts = {}
        for category in sorted(os.listdir(self.treePath)):
            categoryPath = self.treePath + '/' + category
            if (not os.path.isdir(categoryPath) or category[0] == '.'
                or '-' not in category):
                continue
            for port in sorted(os.listdir(categoryPath)):
                portPath = categoryPath + '/' + port
                if not os.path.isdir(portPath) or port[0] == '.':
                    continue
                for recipe in os.listdir(portPath):
                    recipePath = portPath + '/' + recipe
                    if (not os.path.isfile(recipePath) 
                        or not recipe.endswith('.recipe')):
                        continue
                    reWithVersion = re.compile(regExp['recipefilename'])
                    m = reWithVersion.match(recipe)
                    if (m and m.group('name') and m.group('version')):
                        name = m.group('name')
                        version = m.group('version')
                        self.allPorts[recipePath] = Port(name, version, 
                                                         category, portPath, 
                                                         self.shellVariables)
                    else:
                        # invalid argument
                        print("Error: Couldn't parse port/version info: " 
                              + recipe)
        return self.allPorts


# -- /etc/haikuports.conf and *.recipe parser --------------------------------

class Config:
    def __init__(self, filename, keysAndTypes, shellVariables={}):
        self.entries = {}

        # set up the shell environment -- we want it to inherit some of our
        # variables
        shellEnv = os.environ
        shellEnv.update(shellVariables)

        # execute the config file via the shell ....
        supportedKeysString = ' '.join(keysAndTypes.keys())
        wrapperScript = configFileEvaluatorScript % (filename, 
                                                     supportedKeysString)
        try:
            output = check_output(['/bin/bash', '-c', wrapperScript], 
                                  env=shellEnv)
        except (OSError, CalledProcessError):
            sys.exit("Error: Can't evaluate config file: " + filename)

        # ... and collect the resulting configurations (one per line)
        lines = output.splitlines()
        for line in lines:
            key, separator, valueString = line.partition('=')
            if not separator:
                sys.exit('Error: evaluating file %s produced illegal '
                         'key-values line:\n  %s\nexpected "<key>=<value>"\n'
                         'output of configuration script was: %s\n' 
                         % (filename, line, output))
                
            if key not in keysAndTypes:
                # skip unsupported key, just in case
                print('Warning: key %s in file %s is unsupported, ignoring it'
                      % (key, filename))
                continue
            
            valueString = valueString.replace(r'\n', '\n')
                # replace quoted newlines by real newlines
                
            type = keysAndTypes[key]
            if type == types.StringType:
                self.entries[key] = valueString
            elif type == types.IntType:
                try:
                    self.entries[key] = int(valueString)
                except ValueError:
                    sys.exit('Error: evaluating file %s produced illegal value '
                             '"%s" for key %s, expected an <integer> value'
                             % (filename, key, valueString))
            elif type == types.ListType:
                values = [v.strip() for v in valueString.splitlines()]
                self.entries[key] = values
            elif type == PhaseType:
                if valueString.upper() not in PhaseType.getAllowedValues():
                    sys.exit('Error: evaluating file %s\nproduced illegal '
                             'value "%s" for key %s\nexpected one of: %s'
                             % (filename, key, valueString, 
                                ','.join(PhaseType.getAllowedValues())))
                self.entries[key] = valueString.upper()
            elif type == ArchitecturesType:
                self.entries[key] = {}
                for value in [v.lower() for v in valueString.split()]:
                    status = ''
                    architecture = ''
                    if value.startswith('?'):
                        status = 'untested'
                        architecture = value[1:]
                    elif value.startswith('-'):
                        status = 'broken'
                        architecture = value[1:]
                    else:
                        status = 'stable'
                        architecture = value
                    if architecture not in ArchitecturesType.getArchitectures():
                        architectures \
                            = ','.join(ArchitecturesType.getArchitectures())
                        sys.exit('Error: %s refers to unknown architecture %s\n'
                                 'known architectures: %s'
                                 % (filename, architecture, architectures))
                    self.entries[key][architecture] = status
                if 'any' in self.entries[key] and len(self.entries[key]) > 1:
                    sys.exit("Error: %s specifies both 'any' and other "
                             'architectures' % (filename))
            else:
                sys.exit('Error: type of key %s in file %s is unsupported'
                         % (key, filename))
        # for key in self.entries:
        #    print key + " = " + str(self.entries[key])

    def getEntries(self):
        return self.entries

    def valueOf(self, key):
        try:
            value = self.entries[key]
            return value
        except KeyError:
            # an unspecified entry is the same as an empty one
            return ''


# -- Command line argument parsing -------------------------------------------

parser =  OptionParser(usage='usage: %prog [options] portname[-portversion]',
                       version='%prog ' + info['version'])

parser.add_option('-l', '--list', action='store_true', dest='list',
                  default=False, help='list available ports')
parser.add_option('-a', '--about', action='store_true', dest='about',
                  default=False, help='show description of the specified port')
parser.add_option('-s', '--search', action='store_true', dest='search',
                  default=False, help='search for a port (regex)')
parser.add_option('-n', '--nopatch', action='store_false', dest='patch',
                  default=True, help="don't patch the sources, just download "
                                     "and unpack")
parser.add_option('-b', '--nobuild', action='store_false', dest='build',
                  default=True, help="don't build the port, just download, "
                                     "unpack and patch")
parser.add_option('-p', '--nopackage', action='store_false', dest='package',
                  default=True, help="don't create package, stop after build")
parser.add_option('-C', '--nochroot', action='store_false', dest='chroot',
                  default=True, help="don't use a chroot()-environment")
parser.add_option('-c', '--clean', action='store_true', dest='clean',
                  default=False, help="clean the working directory of the "
                                      "specified port")
parser.add_option('-g', '--get', action='store_true', dest='get',
                  default=False, help="get/update the ports tree")
parser.add_option('-f', '--force', action='store_true', dest='force',
                  default=False, help="force to perform the steps (unpack, "
                                      "patch, build)")
parser.add_option('-q', '--quiet', action='store_true', dest='quiet',
                  default=False, help="suppress output from build actions")
parser.add_option('-z', '--archive', action='store_true', dest='archive',
                  default=False, help="Create a patched source archive as "
                                      "<package>_haiku.tar.xz")
parser.add_option('-t', '--tree', action='store_true', dest='tree',
                  default=False, help="print out the location of the "
                                      "haikuports source tree")
parser.add_option('-y', '--yes', action='store_true', dest='yes',
                  default=False, help="answer yes to all questions")
parser.add_option('-j', action='store', type="int", dest='jobs',
                  default=1, help="the number of concurrent jobs to build with")
parser.add_option('-o','--location', action='store_true', dest='location',
                default=False, help="print out the location of a recipe "
                                    "(via search) (for scripted editing)")
parser.add_option('--test', action='store_true', dest='test',
                  default=False, help="run tests on resulting binaries")
parser.add_option('--lint', action='store_true', dest='lint',
                  default=False, help="scan the ports tree for problems")

(options, args) = parser.parse_args()
haikuporter = HaikuPorter(options, args)
